import{r as q}from"./index.8e45f264.js";import{a as J,j as P}from"./jsx-runtime.96752331.js";import{R as W}from"./textarea.e03cca18.js";import"./iframe.047c3e6d.js";import"./selection.f2e9739e.js";class w{constructor(t,e,i,n){this.originalStart=t,this.originalLength=e,this.modifiedStart=i,this.modifiedLength=n}getOriginalEnd(){return this.originalStart+this.originalLength}getModifiedEnd(){return this.modifiedStart+this.modifiedLength}}function Q(g){for(let t=0,e=g.length;t<e;t++){const i=g.charCodeAt(t);if(i!==32&&i!==9)return t}return-1}function X(g,t=g.length-1){for(let e=t;e>=0;e--){const i=g.charCodeAt(e);if(i!==32&&i!==9)return e}return-1}function j(g,t){return(t<<5)-t+g|0}function Y(g,t){t=j(149417,t);for(let e=0,i=g.length;e<i;e++)t=j(g.charCodeAt(e),t);return t}class T{static Assert(t,e){if(!t)throw new Error(e)}}class k{static Copy(t,e,i,n,s){for(let a=0;a<s;a++)i[n+a]=t[e+a]}static Copy2(t,e,i,n,s){for(let a=0;a<s;a++)i[n+a]=t[e+a]}}class F{constructor(){this.m_changes=[],this.m_originalStart=1073741824,this.m_modifiedStart=1073741824,this.m_originalCount=0,this.m_modifiedCount=0}MarkNextChange(){(this.m_originalCount>0||this.m_modifiedCount>0)&&this.m_changes.push(new w(this.m_originalStart,this.m_originalCount,this.m_modifiedStart,this.m_modifiedCount)),this.m_originalCount=0,this.m_modifiedCount=0,this.m_originalStart=1073741824,this.m_modifiedStart=1073741824}AddOriginalElement(t,e){this.m_originalStart=Math.min(this.m_originalStart,t),this.m_modifiedStart=Math.min(this.m_modifiedStart,e),this.m_originalCount++}AddModifiedElement(t,e){this.m_originalStart=Math.min(this.m_originalStart,t),this.m_modifiedStart=Math.min(this.m_modifiedStart,e),this.m_modifiedCount++}getChanges(){return(this.m_originalCount>0||this.m_modifiedCount>0)&&this.MarkNextChange(),this.m_changes}getReverseChanges(){return(this.m_originalCount>0||this.m_modifiedCount>0)&&this.MarkNextChange(),this.m_changes.reverse(),this.m_changes}}class O{constructor(t,e,i=null){this.ContinueProcessingPredicate=i,this._originalSequence=t,this._modifiedSequence=e;const[n,s,a]=O._getElements(t),[l,r,o]=O._getElements(e);this._hasStrings=a&&o,this._originalStringElements=n,this._originalElementsOrHash=s,this._modifiedStringElements=l,this._modifiedElementsOrHash=r,this.m_forwardHistory=[],this.m_reverseHistory=[]}static _isStringArray(t){return t.length>0&&typeof t[0]=="string"}static _getElements(t){const e=t.getElements();if(O._isStringArray(e)){const i=new Int32Array(e.length);for(let n=0,s=e.length;n<s;n++)i[n]=Y(e[n],0);return[e,i,!0]}return e instanceof Int32Array?[[],e,!1]:[[],new Int32Array(e),!1]}ElementsAreEqual(t,e){return this._originalElementsOrHash[t]!==this._modifiedElementsOrHash[e]?!1:this._hasStrings?this._originalStringElements[t]===this._modifiedStringElements[e]:!0}ElementsAreStrictEqual(t,e){if(!this.ElementsAreEqual(t,e))return!1;const i=O._getStrictElement(this._originalSequence,t),n=O._getStrictElement(this._modifiedSequence,e);return i===n}static _getStrictElement(t,e){return typeof t.getStrictElement=="function"?t.getStrictElement(e):null}OriginalElementsAreEqual(t,e){return this._originalElementsOrHash[t]!==this._originalElementsOrHash[e]?!1:this._hasStrings?this._originalStringElements[t]===this._originalStringElements[e]:!0}ModifiedElementsAreEqual(t,e){return this._modifiedElementsOrHash[t]!==this._modifiedElementsOrHash[e]?!1:this._hasStrings?this._modifiedStringElements[t]===this._modifiedStringElements[e]:!0}ComputeDiff(t){return this._ComputeDiff(0,this._originalElementsOrHash.length-1,0,this._modifiedElementsOrHash.length-1,t)}_ComputeDiff(t,e,i,n,s){const a=[!1];let l=this.ComputeDiffRecursive(t,e,i,n,a);return s&&(l=this.PrettifyChanges(l)),{quitEarly:a[0],changes:l}}ComputeDiffRecursive(t,e,i,n,s){for(s[0]=!1;t<=e&&i<=n&&this.ElementsAreEqual(t,i);)t++,i++;for(;e>=t&&n>=i&&this.ElementsAreEqual(e,n);)e--,n--;if(t>e||i>n){let h;return i<=n?(T.Assert(t===e+1,"originalStart should only be one more than originalEnd"),h=[new w(t,0,i,n-i+1)]):t<=e?(T.Assert(i===n+1,"modifiedStart should only be one more than modifiedEnd"),h=[new w(t,e-t+1,i,0)]):(T.Assert(t===e+1,"originalStart should only be one more than originalEnd"),T.Assert(i===n+1,"modifiedStart should only be one more than modifiedEnd"),h=[]),h}const a=[0],l=[0],r=this.ComputeRecursionPoint(t,e,i,n,a,l,s),o=a[0],m=l[0];if(r!==null)return r;if(!s[0]){const h=this.ComputeDiffRecursive(t,o,i,m,s);let u=[];return s[0]?u=[new w(o+1,e-(o+1)+1,m+1,n-(m+1)+1)]:u=this.ComputeDiffRecursive(o+1,e,m+1,n,s),this.ConcatenateChanges(h,u)}return[new w(t,e-t+1,i,n-i+1)]}WALKTRACE(t,e,i,n,s,a,l,r,o,m,h,u,d,f,C,S,E,b){let p=null,A=null,N=new F,D=e,M=i,L=d[0]-S[0]-n,y=-1073741824,v=this.m_forwardHistory.length-1;do{const _=L+t;_===D||_<M&&o[_-1]<o[_+1]?(h=o[_+1],f=h-L-n,h<y&&N.MarkNextChange(),y=h,N.AddModifiedElement(h+1,f),L=_+1-t):(h=o[_-1]+1,f=h-L-n,h<y&&N.MarkNextChange(),y=h-1,N.AddOriginalElement(h,f+1),L=_-1-t),v>=0&&(o=this.m_forwardHistory[v],t=o[0],D=1,M=o.length-1)}while(--v>=-1);if(p=N.getReverseChanges(),b[0]){let _=d[0]+1,c=S[0]+1;if(p!==null&&p.length>0){const H=p[p.length-1];_=Math.max(_,H.getOriginalEnd()),c=Math.max(c,H.getModifiedEnd())}A=[new w(_,u-_+1,c,C-c+1)]}else{N=new F,D=a,M=l,L=d[0]-S[0]-r,y=1073741824,v=E?this.m_reverseHistory.length-1:this.m_reverseHistory.length-2;do{const _=L+s;_===D||_<M&&m[_-1]>=m[_+1]?(h=m[_+1]-1,f=h-L-r,h>y&&N.MarkNextChange(),y=h+1,N.AddOriginalElement(h+1,f+1),L=_+1-s):(h=m[_-1],f=h-L-r,h>y&&N.MarkNextChange(),y=h,N.AddModifiedElement(h+1,f+1),L=_-1-s),v>=0&&(m=this.m_reverseHistory[v],s=m[0],D=1,M=m.length-1)}while(--v>=-1);A=N.getChanges()}return this.ConcatenateChanges(p,A)}ComputeRecursionPoint(t,e,i,n,s,a,l){let r=0,o=0,m=0,h=0,u=0,d=0;t--,i--,s[0]=0,a[0]=0,this.m_forwardHistory=[],this.m_reverseHistory=[];const f=e-t+(n-i),C=f+1,S=new Int32Array(C),E=new Int32Array(C),b=n-i,p=e-t,A=t-i,N=e-n,M=(p-b)%2===0;S[b]=t,E[p]=e,l[0]=!1;for(let L=1;L<=f/2+1;L++){let y=0,v=0;m=this.ClipDiagonalBound(b-L,L,b,C),h=this.ClipDiagonalBound(b+L,L,b,C);for(let c=m;c<=h;c+=2){c===m||c<h&&S[c-1]<S[c+1]?r=S[c+1]:r=S[c-1]+1,o=r-(c-b)-A;const H=r;for(;r<e&&o<n&&this.ElementsAreEqual(r+1,o+1);)r++,o++;if(S[c]=r,r+o>y+v&&(y=r,v=o),!M&&Math.abs(c-p)<=L-1&&r>=E[c])return s[0]=r,a[0]=o,H<=E[c]&&1447>0&&L<=1447+1?this.WALKTRACE(b,m,h,A,p,u,d,N,S,E,r,e,s,o,n,a,M,l):null}const _=(y-t+(v-i)-L)/2;if(this.ContinueProcessingPredicate!==null&&!this.ContinueProcessingPredicate(y,_))return l[0]=!0,s[0]=y,a[0]=v,_>0&&1447>0&&L<=1447+1?this.WALKTRACE(b,m,h,A,p,u,d,N,S,E,r,e,s,o,n,a,M,l):(t++,i++,[new w(t,e-t+1,i,n-i+1)]);u=this.ClipDiagonalBound(p-L,L,p,C),d=this.ClipDiagonalBound(p+L,L,p,C);for(let c=u;c<=d;c+=2){c===u||c<d&&E[c-1]>=E[c+1]?r=E[c+1]-1:r=E[c-1],o=r-(c-p)-N;const H=r;for(;r>t&&o>i&&this.ElementsAreEqual(r,o);)r--,o--;if(E[c]=r,M&&Math.abs(c-b)<=L&&r<=S[c])return s[0]=r,a[0]=o,H>=S[c]&&1447>0&&L<=1447+1?this.WALKTRACE(b,m,h,A,p,u,d,N,S,E,r,e,s,o,n,a,M,l):null}if(L<=1447){let c=new Int32Array(h-m+2);c[0]=b-m+1,k.Copy2(S,m,c,1,h-m+1),this.m_forwardHistory.push(c),c=new Int32Array(d-u+2),c[0]=p-u+1,k.Copy2(E,u,c,1,d-u+1),this.m_reverseHistory.push(c)}}return this.WALKTRACE(b,m,h,A,p,u,d,N,S,E,r,e,s,o,n,a,M,l)}PrettifyChanges(t){for(let e=0;e<t.length;e++){const i=t[e],n=e<t.length-1?t[e+1].originalStart:this._originalElementsOrHash.length,s=e<t.length-1?t[e+1].modifiedStart:this._modifiedElementsOrHash.length,a=i.originalLength>0,l=i.modifiedLength>0;for(;i.originalStart+i.originalLength<n&&i.modifiedStart+i.modifiedLength<s&&(!a||this.OriginalElementsAreEqual(i.originalStart,i.originalStart+i.originalLength))&&(!l||this.ModifiedElementsAreEqual(i.modifiedStart,i.modifiedStart+i.modifiedLength));){const o=this.ElementsAreStrictEqual(i.originalStart,i.modifiedStart);if(this.ElementsAreStrictEqual(i.originalStart+i.originalLength,i.modifiedStart+i.modifiedLength)&&!o)break;i.originalStart++,i.modifiedStart++}let r=[null];if(e<t.length-1&&this.ChangesOverlap(t[e],t[e+1],r)){t[e]=r[0],t.splice(e+1,1),e--;continue}}for(let e=t.length-1;e>=0;e--){const i=t[e];let n=0,s=0;if(e>0){const h=t[e-1];n=h.originalStart+h.originalLength,s=h.modifiedStart+h.modifiedLength}const a=i.originalLength>0,l=i.modifiedLength>0;let r=0,o=this._boundaryScore(i.originalStart,i.originalLength,i.modifiedStart,i.modifiedLength);for(let h=1;;h++){const u=i.originalStart-h,d=i.modifiedStart-h;if(u<n||d<s||a&&!this.OriginalElementsAreEqual(u,u+i.originalLength)||l&&!this.ModifiedElementsAreEqual(d,d+i.modifiedLength))break;const C=(u===n&&d===s?5:0)+this._boundaryScore(u,i.originalLength,d,i.modifiedLength);C>o&&(o=C,r=h)}i.originalStart-=r,i.modifiedStart-=r;const m=[null];if(e>0&&this.ChangesOverlap(t[e-1],t[e],m)){t[e-1]=m[0],t.splice(e,1),e++;continue}}if(this._hasStrings)for(let e=1,i=t.length;e<i;e++){const n=t[e-1],s=t[e],a=s.originalStart-n.originalStart-n.originalLength,l=n.originalStart,r=s.originalStart+s.originalLength,o=r-l,m=n.modifiedStart,h=s.modifiedStart+s.modifiedLength,u=h-m;if(a<5&&o<20&&u<20){const d=this._findBetterContiguousSequence(l,o,m,u,a);if(d){const[f,C]=d;(f!==n.originalStart+n.originalLength||C!==n.modifiedStart+n.modifiedLength)&&(n.originalLength=f-n.originalStart,n.modifiedLength=C-n.modifiedStart,s.originalStart=f+a,s.modifiedStart=C+a,s.originalLength=r-s.originalStart,s.modifiedLength=h-s.modifiedStart)}}}return t}_findBetterContiguousSequence(t,e,i,n,s){if(e<s||n<s)return null;const a=t+e-s+1,l=i+n-s+1;let r=0,o=0,m=0;for(let h=t;h<a;h++)for(let u=i;u<l;u++){const d=this._contiguousSequenceScore(h,u,s);d>0&&d>r&&(r=d,o=h,m=u)}return r>0?[o,m]:null}_contiguousSequenceScore(t,e,i){let n=0;for(let s=0;s<i;s++){if(!this.ElementsAreEqual(t+s,e+s))return 0;n+=this._originalStringElements[t+s].length}return n}_OriginalIsBoundary(t){return t<=0||t>=this._originalElementsOrHash.length-1?!0:this._hasStrings&&/^\s*$/.test(this._originalStringElements[t])}_OriginalRegionIsBoundary(t,e){if(this._OriginalIsBoundary(t)||this._OriginalIsBoundary(t-1))return!0;if(e>0){const i=t+e;if(this._OriginalIsBoundary(i-1)||this._OriginalIsBoundary(i))return!0}return!1}_ModifiedIsBoundary(t){return t<=0||t>=this._modifiedElementsOrHash.length-1?!0:this._hasStrings&&/^\s*$/.test(this._modifiedStringElements[t])}_ModifiedRegionIsBoundary(t,e){if(this._ModifiedIsBoundary(t)||this._ModifiedIsBoundary(t-1))return!0;if(e>0){const i=t+e;if(this._ModifiedIsBoundary(i-1)||this._ModifiedIsBoundary(i))return!0}return!1}_boundaryScore(t,e,i,n){const s=this._OriginalRegionIsBoundary(t,e)?1:0,a=this._ModifiedRegionIsBoundary(i,n)?1:0;return s+a}ConcatenateChanges(t,e){let i=[];if(t.length===0||e.length===0)return e.length>0?e:t;if(this.ChangesOverlap(t[t.length-1],e[0],i)){const n=new Array(t.length+e.length-1);return k.Copy(t,0,n,0,t.length-1),n[t.length-1]=i[0],k.Copy(e,1,n,t.length,e.length-1),n}else{const n=new Array(t.length+e.length);return k.Copy(t,0,n,0,t.length),k.Copy(e,0,n,t.length,e.length),n}}ChangesOverlap(t,e,i){if(T.Assert(t.originalStart<=e.originalStart,"Left change is not less than or equal to right change"),T.Assert(t.modifiedStart<=e.modifiedStart,"Left change is not less than or equal to right change"),t.originalStart+t.originalLength>=e.originalStart||t.modifiedStart+t.modifiedLength>=e.modifiedStart){const n=t.originalStart;let s=t.originalLength;const a=t.modifiedStart;let l=t.modifiedLength;return t.originalStart+t.originalLength>=e.originalStart&&(s=e.originalStart+e.originalLength-t.originalStart),t.modifiedStart+t.modifiedLength>=e.modifiedStart&&(l=e.modifiedStart+e.modifiedLength-t.modifiedStart),i[0]=new w(n,s,a,l),!0}else return i[0]=null,!1}ClipDiagonalBound(t,e,i,n){if(t>=0&&t<n)return t;const s=i,a=n-i-1,l=e%2===0;if(t<0){const r=s%2===0;return l===r?0:1}else{const r=a%2===0;return l===r?n-1:n-2}}}const Z=3;function U(g,t,e,i){return new O(g,t,e).ComputeDiff(i)}class z{constructor(t){const e=[],i=[];for(let n=0,s=t.length;n<s;n++)e[n]=x(t[n],1),i[n]=I(t[n],1);this.lines=t,this._startColumns=e,this._endColumns=i}getElements(){const t=[];for(let e=0,i=this.lines.length;e<i;e++)t[e]=this.lines[e].substring(this._startColumns[e]-1,this._endColumns[e]-1);return t}getStrictElement(t){return this.lines[t]}getStartLineNumber(t){return t+1}getEndLineNumber(t){return t+1}createCharSequence(t,e,i){const n=[],s=[],a=[];let l=0;for(let r=e;r<=i;r++){const o=this.lines[r],m=t?this._startColumns[r]:1,h=t?this._endColumns[r]:o.length+1;for(let u=m;u<h;u++)n[l]=o.charCodeAt(u-1),s[l]=r+1,a[l]=u,l++}return new V(n,s,a)}}class V{constructor(t,e,i){this._charCodes=t,this._lineNumbers=e,this._columns=i}getElements(){return this._charCodes}getStartLineNumber(t){return this._lineNumbers[t]}getStartColumn(t){return this._columns[t]}getEndLineNumber(t){return this._lineNumbers[t]}getEndColumn(t){return this._columns[t]+1}}class B{constructor(t,e,i,n,s,a,l,r){this.originalStartLineNumber=t,this.originalStartColumn=e,this.originalEndLineNumber=i,this.originalEndColumn=n,this.modifiedStartLineNumber=s,this.modifiedStartColumn=a,this.modifiedEndLineNumber=l,this.modifiedEndColumn=r}static createFromDiffChange(t,e,i){let n,s,a,l,r,o,m,h;return t.originalLength===0?(n=0,s=0,a=0,l=0):(n=e.getStartLineNumber(t.originalStart),s=e.getStartColumn(t.originalStart),a=e.getEndLineNumber(t.originalStart+t.originalLength-1),l=e.getEndColumn(t.originalStart+t.originalLength-1)),t.modifiedLength===0?(r=0,o=0,m=0,h=0):(r=i.getStartLineNumber(t.modifiedStart),o=i.getStartColumn(t.modifiedStart),m=i.getEndLineNumber(t.modifiedStart+t.modifiedLength-1),h=i.getEndColumn(t.modifiedStart+t.modifiedLength-1)),new B(n,s,a,l,r,o,m,h)}}function tt(g){if(g.length<=1)return g;const t=[g[0]];let e=t[0];for(let i=1,n=g.length;i<n;i++){const s=g[i],a=s.originalStart-(e.originalStart+e.originalLength),l=s.modifiedStart-(e.modifiedStart+e.modifiedLength);Math.min(a,l)<Z?(e.originalLength=s.originalStart+s.originalLength-e.originalStart,e.modifiedLength=s.modifiedStart+s.modifiedLength-e.modifiedStart):(t.push(s),e=s)}return t}class R{constructor(t,e,i,n,s){this.originalStartLineNumber=t,this.originalEndLineNumber=e,this.modifiedStartLineNumber=i,this.modifiedEndLineNumber=n,this.charChanges=s}static createFromDiffResult(t,e,i,n,s,a,l){let r,o,m,h,u;if(e.originalLength===0?(r=i.getStartLineNumber(e.originalStart)-1,o=0):(r=i.getStartLineNumber(e.originalStart),o=i.getEndLineNumber(e.originalStart+e.originalLength-1)),e.modifiedLength===0?(m=n.getStartLineNumber(e.modifiedStart)-1,h=0):(m=n.getStartLineNumber(e.modifiedStart),h=n.getEndLineNumber(e.modifiedStart+e.modifiedLength-1)),a&&e.originalLength>0&&e.originalLength<20&&e.modifiedLength>0&&e.modifiedLength<20&&s()){const d=i.createCharSequence(t,e.originalStart,e.originalStart+e.originalLength-1),f=n.createCharSequence(t,e.modifiedStart,e.modifiedStart+e.modifiedLength-1);let C=U(d,f,s,!0).changes;l&&(C=tt(C)),u=[];for(let S=0,E=C.length;S<E;S++)u.push(B.createFromDiffChange(C[S],d,f))}return new R(r,o,m,h,u)}}class et{constructor(t,e,i){this.shouldComputeCharChanges=i.shouldComputeCharChanges,this.shouldPostProcessCharChanges=i.shouldPostProcessCharChanges,this.shouldIgnoreTrimWhitespace=i.shouldIgnoreTrimWhitespace,this.shouldMakePrettyDiff=i.shouldMakePrettyDiff,this.originalLines=t,this.modifiedLines=e,this.original=new z(t),this.modified=new z(e),this.continueLineDiff=K(i.maxComputationTime),this.continueCharDiff=K(i.maxComputationTime===0?0:Math.min(i.maxComputationTime,5e3))}computeDiff(){if(this.original.lines.length===1&&this.original.lines[0].length===0)return this.modified.lines.length===1&&this.modified.lines[0].length===0?{quitEarly:!1,changes:[]}:{quitEarly:!1,changes:[{originalStartLineNumber:1,originalEndLineNumber:1,modifiedStartLineNumber:1,modifiedEndLineNumber:this.modified.lines.length,charChanges:[{modifiedEndColumn:0,modifiedEndLineNumber:0,modifiedStartColumn:0,modifiedStartLineNumber:0,originalEndColumn:0,originalEndLineNumber:0,originalStartColumn:0,originalStartLineNumber:0}]}]};if(this.modified.lines.length===1&&this.modified.lines[0].length===0)return{quitEarly:!1,changes:[{originalStartLineNumber:1,originalEndLineNumber:this.original.lines.length,modifiedStartLineNumber:1,modifiedEndLineNumber:1,charChanges:[{modifiedEndColumn:0,modifiedEndLineNumber:0,modifiedStartColumn:0,modifiedStartLineNumber:0,originalEndColumn:0,originalEndLineNumber:0,originalStartColumn:0,originalStartLineNumber:0}]}]};const t=U(this.original,this.modified,this.continueLineDiff,this.shouldMakePrettyDiff),e=t.changes,i=t.quitEarly;if(this.shouldIgnoreTrimWhitespace){const l=[];for(let r=0,o=e.length;r<o;r++)l.push(R.createFromDiffResult(this.shouldIgnoreTrimWhitespace,e[r],this.original,this.modified,this.continueCharDiff,this.shouldComputeCharChanges,this.shouldPostProcessCharChanges));return{quitEarly:i,changes:l}}const n=[];let s=0,a=0;for(let l=-1,r=e.length;l<r;l++){const o=l+1<r?e[l+1]:null,m=o?o.originalStart:this.originalLines.length,h=o?o.modifiedStart:this.modifiedLines.length;for(;s<m&&a<h;){const u=this.originalLines[s],d=this.modifiedLines[a];if(u!==d){{let f=x(u,1),C=x(d,1);for(;f>1&&C>1;){const S=u.charCodeAt(f-2),E=d.charCodeAt(C-2);if(S!==E)break;f--,C--}(f>1||C>1)&&this._pushTrimWhitespaceCharChange(n,s+1,1,f,a+1,1,C)}{let f=I(u,1),C=I(d,1);const S=u.length+1,E=d.length+1;for(;f<S&&C<E;){const b=u.charCodeAt(f-1),p=u.charCodeAt(C-1);if(b!==p)break;f++,C++}(f<S||C<E)&&this._pushTrimWhitespaceCharChange(n,s+1,f,S,a+1,C,E)}}s++,a++}o&&(n.push(R.createFromDiffResult(this.shouldIgnoreTrimWhitespace,o,this.original,this.modified,this.continueCharDiff,this.shouldComputeCharChanges,this.shouldPostProcessCharChanges)),s+=o.originalLength,a+=o.modifiedLength)}return{quitEarly:i,changes:n}}_pushTrimWhitespaceCharChange(t,e,i,n,s,a,l){if(this._mergeTrimWhitespaceCharChange(t,e,i,n,s,a,l))return;let r;this.shouldComputeCharChanges&&(r=[new B(e,i,e,n,s,a,s,l)]),t.push(new R(e,e,s,s,r))}_mergeTrimWhitespaceCharChange(t,e,i,n,s,a,l){const r=t.length;if(r===0)return!1;const o=t[r-1];return o.originalEndLineNumber===0||o.modifiedEndLineNumber===0?!1:o.originalEndLineNumber+1===e&&o.modifiedEndLineNumber+1===s?(o.originalEndLineNumber=e,o.modifiedEndLineNumber=s,this.shouldComputeCharChanges&&o.charChanges&&o.charChanges.push(new B(e,i,e,n,s,a,s,l)),!0):!1}}function x(g,t){const e=Q(g);return e===-1?t:e+1}function I(g,t){const e=X(g);return e===-1?t:e+2}function K(g){if(g===0)return()=>!0;const t=Date.now();return()=>Date.now()-t<g}var it=(g,t,e={})=>new et(g,t,Object.assign({shouldComputeCharChanges:!0,shouldPostProcessCharChanges:!0,shouldIgnoreTrimWhitespace:!0,shouldMakePrettyDiff:!0,maxComputationTime:5e3},e)).computeDiff().changes;const at={component:W},$={width:"300px",height:"400px"},G=(g,t)=>e=>{var a;const i=Array.from({length:e.length}),n=Array.from({length:e.length});for(const l of g){for(let r=l.originalStartLineNumber;r<=l.originalEndLineNumber;r++)i[r-1]||(i[r-1]=[]),l.modifiedEndLineNumber===0&&i[r-1].push({start:void 0,end:void 0});for(let r=l.modifiedStartLineNumber;r<=l.modifiedEndLineNumber;r++)n[r-1]||(n[r-1]=[]),l.originalEndLineNumber===0&&n[r-1].push({start:void 0,end:void 0});(a=l.charChanges)==null||a.forEach(r=>{for(let o=r.originalStartLineNumber;o<=r.originalEndLineNumber;o++)o===r.originalStartLineNumber?r.originalStartLineNumber===r.originalEndLineNumber?(i[o-1]||(i[o-1]=[])).push({start:r.originalStartColumn,end:r.originalEndColumn}):(i[o-1]||(i[o-1]=[])).push({start:r.originalStartColumn,end:void 0}):o===r.originalEndLineNumber?(i[o-1]||(i[o-1]=[])).push({start:void 0,end:r.originalEndColumn}):(i[o-1]||(i[o-1]=[])).push({start:void 0,end:void 0});for(let o=r.modifiedStartLineNumber;o<=r.modifiedEndLineNumber;o++)o===r.modifiedStartLineNumber?r.modifiedStartLineNumber===r.modifiedEndLineNumber?(n[o-1]||(n[o-1]=[])).push({start:r.modifiedStartColumn,end:r.modifiedEndColumn}):(n[o-1]||(n[o-1]=[])).push({start:r.modifiedStartColumn,end:void 0}):o===r.modifiedEndLineNumber?(n[o-1]||(n[o-1]=[])).push({start:void 0,end:r.modifiedEndColumn}):(n[o-1]||(n[o-1]=[])).push({start:void 0,end:void 0})})}const s=t==="base"?{background:"rgba(255, 0, 0, 0.2)"}:{background:"rgba(155, 185, 85, 0.2)"};return e.split(`
`).map((l,r)=>{const o=t==="base"&&i[r]||t==="target"&&n[r]||void 0;let m=[l];if(o&&o.length){let h=0;const u=[];for(let d=0;d<o.length;d++){const f=o[d],C=f.start?f.start-1:0,S=f.end?f.end-1:l.length;u.push(l.slice(h,C)),u.push(P("span",{style:s,children:l.slice(C,S)},`${r}-${d}`)),h=S}u.push(l.slice(h)),m=u}return m.push(" "),P("div",{style:o&&s,children:m},r)})},ht={render:()=>{const[g,t]=q.exports.useState(`This line is removed on the right.
just some text
abcd
efgh
Some more text
Some more text
Some more text`),[e,i]=q.exports.useState(`just some text
abcz
zzzzefgh
Some more text.
This line is removed on the left.`),n=q.exports.useMemo(()=>it(g.split(`
`),e.split(`
`)),[g,e]);return J("div",{children:[P(W,{style:$,onChange:s=>t(s.target.value),value:g,children:G(n,"base")}),P(W,{style:$,onChange:s=>i(s.target.value),value:e,children:G(n,"target")})]})}},ut=["Diff"];export{ht as Diff,ut as __namedExportsOrder,at as default};
//# sourceMappingURL=Diff.stories.837b48c1.js.map
