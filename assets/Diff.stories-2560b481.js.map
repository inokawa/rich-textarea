{"version":3,"file":"Diff.stories-2560b481.js","sources":["../../node_modules/monaco-diff/lib/index.mjs"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Represents information about a specific difference between two sequences.\n */\nclass DiffChange {\n    /**\n     * Constructs a new DiffChange with the given sequence information\n     * and content.\n     */\n    constructor(originalStart, originalLength, modifiedStart, modifiedLength) {\n        //Debug.Assert(originalLength > 0 || modifiedLength > 0, \"originalLength and modifiedLength cannot both be <= 0\");\n        this.originalStart = originalStart;\n        this.originalLength = originalLength;\n        this.modifiedStart = modifiedStart;\n        this.modifiedLength = modifiedLength;\n    }\n    /**\n     * The end point (exclusive) of the change in the original sequence.\n     */\n    getOriginalEnd() {\n        return this.originalStart + this.originalLength;\n    }\n    /**\n     * The end point (exclusive) of the change in the modified sequence.\n     */\n    getModifiedEnd() {\n        return this.modifiedStart + this.modifiedLength;\n    }\n}\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Returns first index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nfunction firstNonWhitespaceIndex(str) {\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chCode = str.charCodeAt(i);\n        if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {\n            return i;\n        }\n    }\n    return -1;\n}\n/**\n * Returns last index of the string that is not whitespace.\n * If string is empty or contains only whitespaces, returns -1\n */\nfunction lastNonWhitespaceIndex(str, startIndex = str.length - 1) {\n    for (let i = startIndex; i >= 0; i--) {\n        const chCode = str.charCodeAt(i);\n        if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction numberHash(val, initialHashVal) {\n    return (((initialHashVal << 5) - initialHashVal) + val) | 0; // hashVal * 31 + ch, keep as int32\n}\nfunction stringHash(s, hashVal) {\n    hashVal = numberHash(149417, hashVal);\n    for (let i = 0, length = s.length; i < length; i++) {\n        hashVal = numberHash(s.charCodeAt(i), hashVal);\n    }\n    return hashVal;\n}\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n//\n// The code below has been ported from a C# implementation in VS\n//\nclass Debug {\n    static Assert(condition, message) {\n        if (!condition) {\n            throw new Error(message);\n        }\n    }\n}\nclass MyArray {\n    /**\n     * Copies a range of elements from an Array starting at the specified source index and pastes\n     * them to another Array starting at the specified destination index. The length and the indexes\n     * are specified as 64-bit integers.\n     * sourceArray:\n     *\t\tThe Array that contains the data to copy.\n     * sourceIndex:\n     *\t\tA 64-bit integer that represents the index in the sourceArray at which copying begins.\n     * destinationArray:\n     *\t\tThe Array that receives the data.\n     * destinationIndex:\n     *\t\tA 64-bit integer that represents the index in the destinationArray at which storing begins.\n     * length:\n     *\t\tA 64-bit integer that represents the number of elements to copy.\n     */\n    static Copy(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\n        for (let i = 0; i < length; i++) {\n            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n        }\n    }\n    static Copy2(sourceArray, sourceIndex, destinationArray, destinationIndex, length) {\n        for (let i = 0; i < length; i++) {\n            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];\n        }\n    }\n}\n/**\n * A utility class which helps to create the set of DiffChanges from\n * a difference operation. This class accepts original DiffElements and\n * modified DiffElements that are involved in a particular change. The\n * MarkNextChange() method can be called to mark the separation between\n * distinct changes. At the end, the Changes property can be called to retrieve\n * the constructed changes.\n */\nclass DiffChangeHelper {\n    /**\n     * Constructs a new DiffChangeHelper for the given DiffSequences.\n     */\n    constructor() {\n        this.m_changes = [];\n        this.m_originalStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n        this.m_modifiedStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n        this.m_originalCount = 0;\n        this.m_modifiedCount = 0;\n    }\n    /**\n     * Marks the beginning of the next change in the set of differences.\n     */\n    MarkNextChange() {\n        // Only add to the list if there is something to add\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n            // Add the new change to our list\n            this.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));\n        }\n        // Reset for the next change\n        this.m_originalCount = 0;\n        this.m_modifiedCount = 0;\n        this.m_originalStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n        this.m_modifiedStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n    }\n    /**\n     * Adds the original element at the given position to the elements\n     * affected by the current change. The modified index gives context\n     * to the change position with respect to the original sequence.\n     * @param originalIndex The index of the original element to add.\n     * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.\n     */\n    AddOriginalElement(originalIndex, modifiedIndex) {\n        // The 'true' start index is the smallest of the ones we've seen\n        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n        this.m_originalCount++;\n    }\n    /**\n     * Adds the modified element at the given position to the elements\n     * affected by the current change. The original index gives context\n     * to the change position with respect to the modified sequence.\n     * @param originalIndex The index of the original element that provides corresponding position in the original sequence.\n     * @param modifiedIndex The index of the modified element to add.\n     */\n    AddModifiedElement(originalIndex, modifiedIndex) {\n        // The 'true' start index is the smallest of the ones we've seen\n        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);\n        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);\n        this.m_modifiedCount++;\n    }\n    /**\n     * Retrieves all of the changes marked by the class.\n     */\n    getChanges() {\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n            // Finish up on whatever is left\n            this.MarkNextChange();\n        }\n        return this.m_changes;\n    }\n    /**\n     * Retrieves all of the changes marked by the class in the reverse order\n     */\n    getReverseChanges() {\n        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {\n            // Finish up on whatever is left\n            this.MarkNextChange();\n        }\n        this.m_changes.reverse();\n        return this.m_changes;\n    }\n}\n/**\n * An implementation of the difference algorithm described in\n * \"An O(ND) Difference Algorithm and its variations\" by Eugene W. Myers\n */\nclass LcsDiff {\n    /**\n     * Constructs the DiffFinder\n     */\n    constructor(originalSequence, modifiedSequence, continueProcessingPredicate = null) {\n        this.ContinueProcessingPredicate = continueProcessingPredicate;\n        this._originalSequence = originalSequence;\n        this._modifiedSequence = modifiedSequence;\n        const [originalStringElements, originalElementsOrHash, originalHasStrings] = LcsDiff._getElements(originalSequence);\n        const [modifiedStringElements, modifiedElementsOrHash, modifiedHasStrings] = LcsDiff._getElements(modifiedSequence);\n        this._hasStrings = (originalHasStrings && modifiedHasStrings);\n        this._originalStringElements = originalStringElements;\n        this._originalElementsOrHash = originalElementsOrHash;\n        this._modifiedStringElements = modifiedStringElements;\n        this._modifiedElementsOrHash = modifiedElementsOrHash;\n        this.m_forwardHistory = [];\n        this.m_reverseHistory = [];\n    }\n    static _isStringArray(arr) {\n        return (arr.length > 0 && typeof arr[0] === 'string');\n    }\n    static _getElements(sequence) {\n        const elements = sequence.getElements();\n        if (LcsDiff._isStringArray(elements)) {\n            const hashes = new Int32Array(elements.length);\n            for (let i = 0, len = elements.length; i < len; i++) {\n                hashes[i] = stringHash(elements[i], 0);\n            }\n            return [elements, hashes, true];\n        }\n        if (elements instanceof Int32Array) {\n            return [[], elements, false];\n        }\n        return [[], new Int32Array(elements), false];\n    }\n    ElementsAreEqual(originalIndex, newIndex) {\n        if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {\n            return false;\n        }\n        return (this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true);\n    }\n    ElementsAreStrictEqual(originalIndex, newIndex) {\n        if (!this.ElementsAreEqual(originalIndex, newIndex)) {\n            return false;\n        }\n        const originalElement = LcsDiff._getStrictElement(this._originalSequence, originalIndex);\n        const modifiedElement = LcsDiff._getStrictElement(this._modifiedSequence, newIndex);\n        return (originalElement === modifiedElement);\n    }\n    static _getStrictElement(sequence, index) {\n        if (typeof sequence.getStrictElement === 'function') {\n            return sequence.getStrictElement(index);\n        }\n        return null;\n    }\n    OriginalElementsAreEqual(index1, index2) {\n        if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {\n            return false;\n        }\n        return (this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true);\n    }\n    ModifiedElementsAreEqual(index1, index2) {\n        if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {\n            return false;\n        }\n        return (this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true);\n    }\n    ComputeDiff(pretty) {\n        return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);\n    }\n    /**\n     * Computes the differences between the original and modified input\n     * sequences on the bounded range.\n     * @returns An array of the differences between the two input sequences.\n     */\n    _ComputeDiff(originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {\n        const quitEarlyArr = [false];\n        let changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);\n        if (pretty) {\n            // We have to clean up the computed diff to be more intuitive\n            // but it turns out this cannot be done correctly until the entire set\n            // of diffs have been computed\n            changes = this.PrettifyChanges(changes);\n        }\n        return {\n            quitEarly: quitEarlyArr[0],\n            changes: changes\n        };\n    }\n    /**\n     * Private helper method which computes the differences on the bounded range\n     * recursively.\n     * @returns An array of the differences between the two input sequences.\n     */\n    ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {\n        quitEarlyArr[0] = false;\n        // Find the start of the differences\n        while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {\n            originalStart++;\n            modifiedStart++;\n        }\n        // Find the end of the differences\n        while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {\n            originalEnd--;\n            modifiedEnd--;\n        }\n        // In the special case where we either have all insertions or all deletions or the sequences are identical\n        if (originalStart > originalEnd || modifiedStart > modifiedEnd) {\n            let changes;\n            if (modifiedStart <= modifiedEnd) {\n                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n                // All insertions\n                changes = [\n                    new DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)\n                ];\n            }\n            else if (originalStart <= originalEnd) {\n                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n                // All deletions\n                changes = [\n                    new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)\n                ];\n            }\n            else {\n                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');\n                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');\n                // Identical sequences - No differences\n                changes = [];\n            }\n            return changes;\n        }\n        // This problem can be solved using the Divide-And-Conquer technique.\n        const midOriginalArr = [0];\n        const midModifiedArr = [0];\n        const result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);\n        const midOriginal = midOriginalArr[0];\n        const midModified = midModifiedArr[0];\n        if (result !== null) {\n            // Result is not-null when there was enough memory to compute the changes while\n            // searching for the recursion point\n            return result;\n        }\n        else if (!quitEarlyArr[0]) {\n            // We can break the problem down recursively by finding the changes in the\n            // First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)\n            // Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)\n            // NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point\n            const leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);\n            let rightChanges = [];\n            if (!quitEarlyArr[0]) {\n                rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);\n            }\n            else {\n                // We didn't have time to finish the first half, so we don't have time to compute this half.\n                // Consider the entire rest of the sequence different.\n                rightChanges = [\n                    new DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)\n                ];\n            }\n            return this.ConcatenateChanges(leftChanges, rightChanges);\n        }\n        // If we hit here, we quit early, and so can't return anything meaningful\n        return [\n            new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\n        ];\n    }\n    WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {\n        let forwardChanges = null;\n        let reverseChanges = null;\n        // First, walk backward through the forward diagonals history\n        let changeHelper = new DiffChangeHelper();\n        let diagonalMin = diagonalForwardStart;\n        let diagonalMax = diagonalForwardEnd;\n        let diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalForwardOffset;\n        let lastOriginalIndex = -1073741824 /* MIN_SAFE_SMALL_INTEGER */;\n        let historyIndex = this.m_forwardHistory.length - 1;\n        do {\n            // Get the diagonal index from the relative diagonal number\n            const diagonal = diagonalRelative + diagonalForwardBase;\n            // Figure out where we came from\n            if (diagonal === diagonalMin || (diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n                // Vertical line (the element is an insert)\n                originalIndex = forwardPoints[diagonal + 1];\n                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n                if (originalIndex < lastOriginalIndex) {\n                    changeHelper.MarkNextChange();\n                }\n                lastOriginalIndex = originalIndex;\n                changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);\n                diagonalRelative = (diagonal + 1) - diagonalForwardBase; //Setup for the next iteration\n            }\n            else {\n                // Horizontal line (the element is a deletion)\n                originalIndex = forwardPoints[diagonal - 1] + 1;\n                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;\n                if (originalIndex < lastOriginalIndex) {\n                    changeHelper.MarkNextChange();\n                }\n                lastOriginalIndex = originalIndex - 1;\n                changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);\n                diagonalRelative = (diagonal - 1) - diagonalForwardBase; //Setup for the next iteration\n            }\n            if (historyIndex >= 0) {\n                forwardPoints = this.m_forwardHistory[historyIndex];\n                diagonalForwardBase = forwardPoints[0]; //We stored this in the first spot\n                diagonalMin = 1;\n                diagonalMax = forwardPoints.length - 1;\n            }\n        } while (--historyIndex >= -1);\n        // Ironically, we get the forward changes as the reverse of the\n        // order we added them since we technically added them backwards\n        forwardChanges = changeHelper.getReverseChanges();\n        if (quitEarlyArr[0]) {\n            // TODO: Calculate a partial from the reverse diagonals.\n            //       For now, just assume everything after the midOriginal/midModified point is a diff\n            let originalStartPoint = midOriginalArr[0] + 1;\n            let modifiedStartPoint = midModifiedArr[0] + 1;\n            if (forwardChanges !== null && forwardChanges.length > 0) {\n                const lastForwardChange = forwardChanges[forwardChanges.length - 1];\n                originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());\n                modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());\n            }\n            reverseChanges = [\n                new DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)\n            ];\n        }\n        else {\n            // Now walk backward through the reverse diagonals history\n            changeHelper = new DiffChangeHelper();\n            diagonalMin = diagonalReverseStart;\n            diagonalMax = diagonalReverseEnd;\n            diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalReverseOffset;\n            lastOriginalIndex = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;\n            historyIndex = (deltaIsEven) ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;\n            do {\n                // Get the diagonal index from the relative diagonal number\n                const diagonal = diagonalRelative + diagonalReverseBase;\n                // Figure out where we came from\n                if (diagonal === diagonalMin || (diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n                    // Horizontal line (the element is a deletion))\n                    originalIndex = reversePoints[diagonal + 1] - 1;\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n                    if (originalIndex > lastOriginalIndex) {\n                        changeHelper.MarkNextChange();\n                    }\n                    lastOriginalIndex = originalIndex + 1;\n                    changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);\n                    diagonalRelative = (diagonal + 1) - diagonalReverseBase; //Setup for the next iteration\n                }\n                else {\n                    // Vertical line (the element is an insertion)\n                    originalIndex = reversePoints[diagonal - 1];\n                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;\n                    if (originalIndex > lastOriginalIndex) {\n                        changeHelper.MarkNextChange();\n                    }\n                    lastOriginalIndex = originalIndex;\n                    changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);\n                    diagonalRelative = (diagonal - 1) - diagonalReverseBase; //Setup for the next iteration\n                }\n                if (historyIndex >= 0) {\n                    reversePoints = this.m_reverseHistory[historyIndex];\n                    diagonalReverseBase = reversePoints[0]; //We stored this in the first spot\n                    diagonalMin = 1;\n                    diagonalMax = reversePoints.length - 1;\n                }\n            } while (--historyIndex >= -1);\n            // There are cases where the reverse history will find diffs that\n            // are correct, but not intuitive, so we need shift them.\n            reverseChanges = changeHelper.getChanges();\n        }\n        return this.ConcatenateChanges(forwardChanges, reverseChanges);\n    }\n    /**\n     * Given the range to compute the diff on, this method finds the point:\n     * (midOriginal, midModified)\n     * that exists in the middle of the LCS of the two sequences and\n     * is the point at which the LCS problem may be broken down recursively.\n     * This method will try to keep the LCS trace in memory. If the LCS recursion\n     * point is calculated and the full trace is available in memory, then this method\n     * will return the change list.\n     * @param originalStart The start bound of the original sequence range\n     * @param originalEnd The end bound of the original sequence range\n     * @param modifiedStart The start bound of the modified sequence range\n     * @param modifiedEnd The end bound of the modified sequence range\n     * @param midOriginal The middle point of the original sequence range\n     * @param midModified The middle point of the modified sequence range\n     * @returns The diff changes, if available, otherwise null\n     */\n    ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {\n        let originalIndex = 0, modifiedIndex = 0;\n        let diagonalForwardStart = 0, diagonalForwardEnd = 0;\n        let diagonalReverseStart = 0, diagonalReverseEnd = 0;\n        // To traverse the edit graph and produce the proper LCS, our actual\n        // start position is just outside the given boundary\n        originalStart--;\n        modifiedStart--;\n        // We set these up to make the compiler happy, but they will\n        // be replaced before we return with the actual recursion point\n        midOriginalArr[0] = 0;\n        midModifiedArr[0] = 0;\n        // Clear out the history\n        this.m_forwardHistory = [];\n        this.m_reverseHistory = [];\n        // Each cell in the two arrays corresponds to a diagonal in the edit graph.\n        // The integer value in the cell represents the originalIndex of the furthest\n        // reaching point found so far that ends in that diagonal.\n        // The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.\n        const maxDifferences = (originalEnd - originalStart) + (modifiedEnd - modifiedStart);\n        const numDiagonals = maxDifferences + 1;\n        const forwardPoints = new Int32Array(numDiagonals);\n        const reversePoints = new Int32Array(numDiagonals);\n        // diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)\n        // diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)\n        const diagonalForwardBase = (modifiedEnd - modifiedStart);\n        const diagonalReverseBase = (originalEnd - originalStart);\n        // diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n        //    diagonal number (relative to diagonalForwardBase)\n        // diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the\n        //    diagonal number (relative to diagonalReverseBase)\n        const diagonalForwardOffset = (originalStart - modifiedStart);\n        const diagonalReverseOffset = (originalEnd - modifiedEnd);\n        // delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers\n        //   relative to the start diagonal with diagonal numbers relative to the end diagonal.\n        // The Even/Oddn-ness of this delta is important for determining when we should check for overlap\n        const delta = diagonalReverseBase - diagonalForwardBase;\n        const deltaIsEven = (delta % 2 === 0);\n        // Here we set up the start and end points as the furthest points found so far\n        // in both the forward and reverse directions, respectively\n        forwardPoints[diagonalForwardBase] = originalStart;\n        reversePoints[diagonalReverseBase] = originalEnd;\n        // Remember if we quit early, and thus need to do a best-effort result instead of a real result.\n        quitEarlyArr[0] = false;\n        // A couple of points:\n        // --With this method, we iterate on the number of differences between the two sequences.\n        //   The more differences there actually are, the longer this will take.\n        // --Also, as the number of differences increases, we have to search on diagonals further\n        //   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).\n        // --We extend on even diagonals (relative to the reference diagonal) only when numDifferences\n        //   is even and odd diagonals only when numDifferences is odd.\n        for (let numDifferences = 1; numDifferences <= (maxDifferences / 2) + 1; numDifferences++) {\n            let furthestOriginalIndex = 0;\n            let furthestModifiedIndex = 0;\n            // Run the algorithm in the forward direction\n            diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n            diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);\n            for (let diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {\n                // STEP 1: We extend the furthest reaching point in the present diagonal\n                // by looking at the diagonals above and below and picking the one whose point\n                // is further away from the start point (originalStart, modifiedStart)\n                if (diagonal === diagonalForwardStart || (diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {\n                    originalIndex = forwardPoints[diagonal + 1];\n                }\n                else {\n                    originalIndex = forwardPoints[diagonal - 1] + 1;\n                }\n                modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;\n                // Save the current originalIndex so we can test for false overlap in step 3\n                const tempOriginalIndex = originalIndex;\n                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n                // so long as the elements are equal.\n                while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {\n                    originalIndex++;\n                    modifiedIndex++;\n                }\n                forwardPoints[diagonal] = originalIndex;\n                if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {\n                    furthestOriginalIndex = originalIndex;\n                    furthestModifiedIndex = modifiedIndex;\n                }\n                // STEP 3: If delta is odd (overlap first happens on forward when delta is odd)\n                // and diagonal is in the range of reverse diagonals computed for numDifferences-1\n                // (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)\n                // then check for overlap.\n                if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= (numDifferences - 1)) {\n                    if (originalIndex >= reversePoints[diagonal]) {\n                        midOriginalArr[0] = originalIndex;\n                        midModifiedArr[0] = modifiedIndex;\n                        if (tempOriginalIndex <= reversePoints[diagonal] && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* MaxDifferencesHistory */ + 1)) {\n                            // BINGO! We overlapped, and we have the full trace in memory!\n                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n                        }\n                        else {\n                            // Either false overlap, or we didn't have enough memory for the full trace\n                            // Just return the recursion point\n                            return null;\n                        }\n                    }\n                }\n            }\n            // Check to see if we should be quitting early, before moving on to the next iteration.\n            const matchLengthOfLongest = ((furthestOriginalIndex - originalStart) + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;\n            if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {\n                // We can't finish, so skip ahead to generating a result from what we have.\n                quitEarlyArr[0] = true;\n                // Use the furthest distance we got in the forward direction.\n                midOriginalArr[0] = furthestOriginalIndex;\n                midModifiedArr[0] = furthestModifiedIndex;\n                if (matchLengthOfLongest > 0 && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* MaxDifferencesHistory */ + 1)) {\n                    // Enough of the history is in memory to walk it backwards\n                    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n                }\n                else {\n                    // We didn't actually remember enough of the history.\n                    //Since we are quitting the diff early, we need to shift back the originalStart and modified start\n                    //back into the boundary limits since we decremented their value above beyond the boundary limit.\n                    originalStart++;\n                    modifiedStart++;\n                    return [\n                        new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)\n                    ];\n                }\n            }\n            // Run the algorithm in the reverse direction\n            diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n            diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);\n            for (let diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {\n                // STEP 1: We extend the furthest reaching point in the present diagonal\n                // by looking at the diagonals above and below and picking the one whose point\n                // is further away from the start point (originalEnd, modifiedEnd)\n                if (diagonal === diagonalReverseStart || (diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {\n                    originalIndex = reversePoints[diagonal + 1] - 1;\n                }\n                else {\n                    originalIndex = reversePoints[diagonal - 1];\n                }\n                modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;\n                // Save the current originalIndex so we can test for false overlap\n                const tempOriginalIndex = originalIndex;\n                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal\n                // as long as the elements are equal.\n                while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {\n                    originalIndex--;\n                    modifiedIndex--;\n                }\n                reversePoints[diagonal] = originalIndex;\n                // STEP 4: If delta is even (overlap first happens on reverse when delta is even)\n                // and diagonal is in the range of forward diagonals computed for numDifferences\n                // then check for overlap.\n                if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {\n                    if (originalIndex <= forwardPoints[diagonal]) {\n                        midOriginalArr[0] = originalIndex;\n                        midModifiedArr[0] = modifiedIndex;\n                        if (tempOriginalIndex >= forwardPoints[diagonal] && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* MaxDifferencesHistory */ + 1)) {\n                            // BINGO! We overlapped, and we have the full trace in memory!\n                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n                        }\n                        else {\n                            // Either false overlap, or we didn't have enough memory for the full trace\n                            // Just return the recursion point\n                            return null;\n                        }\n                    }\n                }\n            }\n            // Save current vectors to history before the next iteration\n            if (numDifferences <= 1447 /* MaxDifferencesHistory */) {\n                // We are allocating space for one extra int, which we fill with\n                // the index of the diagonal base index\n                let temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);\n                temp[0] = diagonalForwardBase - diagonalForwardStart + 1;\n                MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);\n                this.m_forwardHistory.push(temp);\n                temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);\n                temp[0] = diagonalReverseBase - diagonalReverseStart + 1;\n                MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);\n                this.m_reverseHistory.push(temp);\n            }\n        }\n        // If we got here, then we have the full trace in history. We just have to convert it to a change list\n        // NOTE: This part is a bit messy\n        return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);\n    }\n    /**\n     * Shifts the given changes to provide a more intuitive diff.\n     * While the first element in a diff matches the first element after the diff,\n     * we shift the diff down.\n     *\n     * @param changes The list of changes to shift\n     * @returns The shifted changes\n     */\n    PrettifyChanges(changes) {\n        // Shift all the changes down first\n        for (let i = 0; i < changes.length; i++) {\n            const change = changes[i];\n            const originalStop = (i < changes.length - 1) ? changes[i + 1].originalStart : this._originalElementsOrHash.length;\n            const modifiedStop = (i < changes.length - 1) ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;\n            const checkOriginal = change.originalLength > 0;\n            const checkModified = change.modifiedLength > 0;\n            while (change.originalStart + change.originalLength < originalStop\n                && change.modifiedStart + change.modifiedLength < modifiedStop\n                && (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength))\n                && (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {\n                const startStrictEqual = this.ElementsAreStrictEqual(change.originalStart, change.modifiedStart);\n                const endStrictEqual = this.ElementsAreStrictEqual(change.originalStart + change.originalLength, change.modifiedStart + change.modifiedLength);\n                if (endStrictEqual && !startStrictEqual) {\n                    // moving the change down would create an equal change, but the elements are not strict equal\n                    break;\n                }\n                change.originalStart++;\n                change.modifiedStart++;\n            }\n            let mergedChangeArr = [null];\n            if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {\n                changes[i] = mergedChangeArr[0];\n                changes.splice(i + 1, 1);\n                i--;\n                continue;\n            }\n        }\n        // Shift changes back up until we hit empty or whitespace-only lines\n        for (let i = changes.length - 1; i >= 0; i--) {\n            const change = changes[i];\n            let originalStop = 0;\n            let modifiedStop = 0;\n            if (i > 0) {\n                const prevChange = changes[i - 1];\n                originalStop = prevChange.originalStart + prevChange.originalLength;\n                modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;\n            }\n            const checkOriginal = change.originalLength > 0;\n            const checkModified = change.modifiedLength > 0;\n            let bestDelta = 0;\n            let bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);\n            for (let delta = 1;; delta++) {\n                const originalStart = change.originalStart - delta;\n                const modifiedStart = change.modifiedStart - delta;\n                if (originalStart < originalStop || modifiedStart < modifiedStop) {\n                    break;\n                }\n                if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {\n                    break;\n                }\n                if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {\n                    break;\n                }\n                const touchingPreviousChange = (originalStart === originalStop && modifiedStart === modifiedStop);\n                const score = ((touchingPreviousChange ? 5 : 0)\n                    + this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength));\n                if (score > bestScore) {\n                    bestScore = score;\n                    bestDelta = delta;\n                }\n            }\n            change.originalStart -= bestDelta;\n            change.modifiedStart -= bestDelta;\n            const mergedChangeArr = [null];\n            if (i > 0 && this.ChangesOverlap(changes[i - 1], changes[i], mergedChangeArr)) {\n                changes[i - 1] = mergedChangeArr[0];\n                changes.splice(i, 1);\n                i++;\n                continue;\n            }\n        }\n        // There could be multiple longest common substrings.\n        // Give preference to the ones containing longer lines\n        if (this._hasStrings) {\n            for (let i = 1, len = changes.length; i < len; i++) {\n                const aChange = changes[i - 1];\n                const bChange = changes[i];\n                const matchedLength = bChange.originalStart - aChange.originalStart - aChange.originalLength;\n                const aOriginalStart = aChange.originalStart;\n                const bOriginalEnd = bChange.originalStart + bChange.originalLength;\n                const abOriginalLength = bOriginalEnd - aOriginalStart;\n                const aModifiedStart = aChange.modifiedStart;\n                const bModifiedEnd = bChange.modifiedStart + bChange.modifiedLength;\n                const abModifiedLength = bModifiedEnd - aModifiedStart;\n                // Avoid wasting a lot of time with these searches\n                if (matchedLength < 5 && abOriginalLength < 20 && abModifiedLength < 20) {\n                    const t = this._findBetterContiguousSequence(aOriginalStart, abOriginalLength, aModifiedStart, abModifiedLength, matchedLength);\n                    if (t) {\n                        const [originalMatchStart, modifiedMatchStart] = t;\n                        if (originalMatchStart !== aChange.originalStart + aChange.originalLength || modifiedMatchStart !== aChange.modifiedStart + aChange.modifiedLength) {\n                            // switch to another sequence that has a better score\n                            aChange.originalLength = originalMatchStart - aChange.originalStart;\n                            aChange.modifiedLength = modifiedMatchStart - aChange.modifiedStart;\n                            bChange.originalStart = originalMatchStart + matchedLength;\n                            bChange.modifiedStart = modifiedMatchStart + matchedLength;\n                            bChange.originalLength = bOriginalEnd - bChange.originalStart;\n                            bChange.modifiedLength = bModifiedEnd - bChange.modifiedStart;\n                        }\n                    }\n                }\n            }\n        }\n        return changes;\n    }\n    _findBetterContiguousSequence(originalStart, originalLength, modifiedStart, modifiedLength, desiredLength) {\n        if (originalLength < desiredLength || modifiedLength < desiredLength) {\n            return null;\n        }\n        const originalMax = originalStart + originalLength - desiredLength + 1;\n        const modifiedMax = modifiedStart + modifiedLength - desiredLength + 1;\n        let bestScore = 0;\n        let bestOriginalStart = 0;\n        let bestModifiedStart = 0;\n        for (let i = originalStart; i < originalMax; i++) {\n            for (let j = modifiedStart; j < modifiedMax; j++) {\n                const score = this._contiguousSequenceScore(i, j, desiredLength);\n                if (score > 0 && score > bestScore) {\n                    bestScore = score;\n                    bestOriginalStart = i;\n                    bestModifiedStart = j;\n                }\n            }\n        }\n        if (bestScore > 0) {\n            return [bestOriginalStart, bestModifiedStart];\n        }\n        return null;\n    }\n    _contiguousSequenceScore(originalStart, modifiedStart, length) {\n        let score = 0;\n        for (let l = 0; l < length; l++) {\n            if (!this.ElementsAreEqual(originalStart + l, modifiedStart + l)) {\n                return 0;\n            }\n            score += this._originalStringElements[originalStart + l].length;\n        }\n        return score;\n    }\n    _OriginalIsBoundary(index) {\n        if (index <= 0 || index >= this._originalElementsOrHash.length - 1) {\n            return true;\n        }\n        return (this._hasStrings && /^\\s*$/.test(this._originalStringElements[index]));\n    }\n    _OriginalRegionIsBoundary(originalStart, originalLength) {\n        if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {\n            return true;\n        }\n        if (originalLength > 0) {\n            const originalEnd = originalStart + originalLength;\n            if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    _ModifiedIsBoundary(index) {\n        if (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {\n            return true;\n        }\n        return (this._hasStrings && /^\\s*$/.test(this._modifiedStringElements[index]));\n    }\n    _ModifiedRegionIsBoundary(modifiedStart, modifiedLength) {\n        if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {\n            return true;\n        }\n        if (modifiedLength > 0) {\n            const modifiedEnd = modifiedStart + modifiedLength;\n            if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    _boundaryScore(originalStart, originalLength, modifiedStart, modifiedLength) {\n        const originalScore = (this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0);\n        const modifiedScore = (this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0);\n        return (originalScore + modifiedScore);\n    }\n    /**\n     * Concatenates the two input DiffChange lists and returns the resulting\n     * list.\n     * @param The left changes\n     * @param The right changes\n     * @returns The concatenated list\n     */\n    ConcatenateChanges(left, right) {\n        let mergedChangeArr = [];\n        if (left.length === 0 || right.length === 0) {\n            return (right.length > 0) ? right : left;\n        }\n        else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {\n            // Since we break the problem down recursively, it is possible that we\n            // might recurse in the middle of a change thereby splitting it into\n            // two changes. Here in the combining stage, we detect and fuse those\n            // changes back together\n            const result = new Array(left.length + right.length - 1);\n            MyArray.Copy(left, 0, result, 0, left.length - 1);\n            result[left.length - 1] = mergedChangeArr[0];\n            MyArray.Copy(right, 1, result, left.length, right.length - 1);\n            return result;\n        }\n        else {\n            const result = new Array(left.length + right.length);\n            MyArray.Copy(left, 0, result, 0, left.length);\n            MyArray.Copy(right, 0, result, left.length, right.length);\n            return result;\n        }\n    }\n    /**\n     * Returns true if the two changes overlap and can be merged into a single\n     * change\n     * @param left The left change\n     * @param right The right change\n     * @param mergedChange The merged change if the two overlap, null otherwise\n     * @returns True if the two changes overlap\n     */\n    ChangesOverlap(left, right, mergedChangeArr) {\n        Debug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');\n        Debug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');\n        if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n            const originalStart = left.originalStart;\n            let originalLength = left.originalLength;\n            const modifiedStart = left.modifiedStart;\n            let modifiedLength = left.modifiedLength;\n            if (left.originalStart + left.originalLength >= right.originalStart) {\n                originalLength = right.originalStart + right.originalLength - left.originalStart;\n            }\n            if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {\n                modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;\n            }\n            mergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);\n            return true;\n        }\n        else {\n            mergedChangeArr[0] = null;\n            return false;\n        }\n    }\n    /**\n     * Helper method used to clip a diagonal index to the range of valid\n     * diagonals. This also decides whether or not the diagonal index,\n     * if it exceeds the boundary, should be clipped to the boundary or clipped\n     * one inside the boundary depending on the Even/Odd status of the boundary\n     * and numDifferences.\n     * @param diagonal The index of the diagonal to clip.\n     * @param numDifferences The current number of differences being iterated upon.\n     * @param diagonalBaseIndex The base reference diagonal.\n     * @param numDiagonals The total number of diagonals.\n     * @returns The clipped diagonal index.\n     */\n    ClipDiagonalBound(diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {\n        if (diagonal >= 0 && diagonal < numDiagonals) {\n            // Nothing to clip, its in range\n            return diagonal;\n        }\n        // diagonalsBelow: The number of diagonals below the reference diagonal\n        // diagonalsAbove: The number of diagonals above the reference diagonal\n        const diagonalsBelow = diagonalBaseIndex;\n        const diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;\n        const diffEven = (numDifferences % 2 === 0);\n        if (diagonal < 0) {\n            const lowerBoundEven = (diagonalsBelow % 2 === 0);\n            return (diffEven === lowerBoundEven) ? 0 : 1;\n        }\n        else {\n            const upperBoundEven = (diagonalsAbove % 2 === 0);\n            return (diffEven === upperBoundEven) ? numDiagonals - 1 : numDiagonals - 2;\n        }\n    }\n}\n\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst MINIMUM_MATCHING_CHARACTER_LENGTH = 3;\nfunction computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {\n    const diffAlgo = new LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);\n    return diffAlgo.ComputeDiff(pretty);\n}\nclass LineSequence {\n    constructor(lines) {\n        const startColumns = [];\n        const endColumns = [];\n        for (let i = 0, length = lines.length; i < length; i++) {\n            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);\n            endColumns[i] = getLastNonBlankColumn(lines[i], 1);\n        }\n        this.lines = lines;\n        this._startColumns = startColumns;\n        this._endColumns = endColumns;\n    }\n    getElements() {\n        const elements = [];\n        for (let i = 0, len = this.lines.length; i < len; i++) {\n            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);\n        }\n        return elements;\n    }\n    getStrictElement(index) {\n        return this.lines[index];\n    }\n    getStartLineNumber(i) {\n        return i + 1;\n    }\n    getEndLineNumber(i) {\n        return i + 1;\n    }\n    createCharSequence(shouldIgnoreTrimWhitespace, startIndex, endIndex) {\n        const charCodes = [];\n        const lineNumbers = [];\n        const columns = [];\n        let len = 0;\n        for (let index = startIndex; index <= endIndex; index++) {\n            const lineContent = this.lines[index];\n            const startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);\n            const endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);\n            for (let col = startColumn; col < endColumn; col++) {\n                charCodes[len] = lineContent.charCodeAt(col - 1);\n                lineNumbers[len] = index + 1;\n                columns[len] = col;\n                len++;\n            }\n        }\n        return new CharSequence(charCodes, lineNumbers, columns);\n    }\n}\nclass CharSequence {\n    constructor(charCodes, lineNumbers, columns) {\n        this._charCodes = charCodes;\n        this._lineNumbers = lineNumbers;\n        this._columns = columns;\n    }\n    getElements() {\n        return this._charCodes;\n    }\n    getStartLineNumber(i) {\n        return this._lineNumbers[i];\n    }\n    getStartColumn(i) {\n        return this._columns[i];\n    }\n    getEndLineNumber(i) {\n        return this._lineNumbers[i];\n    }\n    getEndColumn(i) {\n        return this._columns[i] + 1;\n    }\n}\nclass CharChange {\n    constructor(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalStartColumn = originalStartColumn;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.originalEndColumn = originalEndColumn;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedStartColumn = modifiedStartColumn;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.modifiedEndColumn = modifiedEndColumn;\n    }\n    static createFromDiffChange(diffChange, originalCharSequence, modifiedCharSequence) {\n        let originalStartLineNumber;\n        let originalStartColumn;\n        let originalEndLineNumber;\n        let originalEndColumn;\n        let modifiedStartLineNumber;\n        let modifiedStartColumn;\n        let modifiedEndLineNumber;\n        let modifiedEndColumn;\n        if (diffChange.originalLength === 0) {\n            originalStartLineNumber = 0;\n            originalStartColumn = 0;\n            originalEndLineNumber = 0;\n            originalEndColumn = 0;\n        }\n        else {\n            originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);\n            originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);\n            originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n            originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);\n        }\n        if (diffChange.modifiedLength === 0) {\n            modifiedStartLineNumber = 0;\n            modifiedStartColumn = 0;\n            modifiedEndLineNumber = 0;\n            modifiedEndColumn = 0;\n        }\n        else {\n            modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);\n            modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);\n            modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n            modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        }\n        return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);\n    }\n}\nfunction postProcessCharChanges(rawChanges) {\n    if (rawChanges.length <= 1) {\n        return rawChanges;\n    }\n    const result = [rawChanges[0]];\n    let prevChange = result[0];\n    for (let i = 1, len = rawChanges.length; i < len; i++) {\n        const currChange = rawChanges[i];\n        const originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);\n        const modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);\n        // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true\n        const matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);\n        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {\n            // Merge the current change into the previous one\n            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;\n            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;\n        }\n        else {\n            // Add the current change\n            result.push(currChange);\n            prevChange = currChange;\n        }\n    }\n    return result;\n}\nclass LineChange {\n    constructor(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {\n        this.originalStartLineNumber = originalStartLineNumber;\n        this.originalEndLineNumber = originalEndLineNumber;\n        this.modifiedStartLineNumber = modifiedStartLineNumber;\n        this.modifiedEndLineNumber = modifiedEndLineNumber;\n        this.charChanges = charChanges;\n    }\n    static createFromDiffResult(shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {\n        let originalStartLineNumber;\n        let originalEndLineNumber;\n        let modifiedStartLineNumber;\n        let modifiedEndLineNumber;\n        let charChanges = undefined;\n        if (diffChange.originalLength === 0) {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;\n            originalEndLineNumber = 0;\n        }\n        else {\n            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);\n            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);\n        }\n        if (diffChange.modifiedLength === 0) {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;\n            modifiedEndLineNumber = 0;\n        }\n        else {\n            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);\n            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);\n        }\n        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {\n            // Compute character changes for diff chunks of at most 20 lines...\n            const originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);\n            const modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);\n            let rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;\n            if (shouldPostProcessCharChanges) {\n                rawChanges = postProcessCharChanges(rawChanges);\n            }\n            charChanges = [];\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\n                charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));\n            }\n        }\n        return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);\n    }\n}\nclass DiffComputer {\n    constructor(originalLines, modifiedLines, opts) {\n        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;\n        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;\n        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;\n        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;\n        this.originalLines = originalLines;\n        this.modifiedLines = modifiedLines;\n        this.original = new LineSequence(originalLines);\n        this.modified = new LineSequence(modifiedLines);\n        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);\n        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...\n    }\n    computeDiff() {\n        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {\n            // empty original => fast path\n            if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n                return {\n                    quitEarly: false,\n                    changes: []\n                };\n            }\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: 1,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: this.modified.lines.length,\n                        charChanges: [{\n                                modifiedEndColumn: 0,\n                                modifiedEndLineNumber: 0,\n                                modifiedStartColumn: 0,\n                                modifiedStartLineNumber: 0,\n                                originalEndColumn: 0,\n                                originalEndLineNumber: 0,\n                                originalStartColumn: 0,\n                                originalStartLineNumber: 0\n                            }]\n                    }]\n            };\n        }\n        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {\n            // empty modified => fast path\n            return {\n                quitEarly: false,\n                changes: [{\n                        originalStartLineNumber: 1,\n                        originalEndLineNumber: this.original.lines.length,\n                        modifiedStartLineNumber: 1,\n                        modifiedEndLineNumber: 1,\n                        charChanges: [{\n                                modifiedEndColumn: 0,\n                                modifiedEndLineNumber: 0,\n                                modifiedStartColumn: 0,\n                                modifiedStartLineNumber: 0,\n                                originalEndColumn: 0,\n                                originalEndLineNumber: 0,\n                                originalStartColumn: 0,\n                                originalStartLineNumber: 0\n                            }]\n                    }]\n            };\n        }\n        const diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);\n        const rawChanges = diffResult.changes;\n        const quitEarly = diffResult.quitEarly;\n        // The diff is always computed with ignoring trim whitespace\n        // This ensures we get the prettiest diff\n        if (this.shouldIgnoreTrimWhitespace) {\n            const lineChanges = [];\n            for (let i = 0, length = rawChanges.length; i < length; i++) {\n                lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n            }\n            return {\n                quitEarly: quitEarly,\n                changes: lineChanges\n            };\n        }\n        // Need to post-process and introduce changes where the trim whitespace is different\n        // Note that we are looping starting at -1 to also cover the lines before the first change\n        const result = [];\n        let originalLineIndex = 0;\n        let modifiedLineIndex = 0;\n        for (let i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {\n            const nextChange = (i + 1 < len ? rawChanges[i + 1] : null);\n            const originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);\n            const modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);\n            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {\n                const originalLine = this.originalLines[originalLineIndex];\n                const modifiedLine = this.modifiedLines[modifiedLineIndex];\n                if (originalLine !== modifiedLine) {\n                    // These lines differ only in trim whitespace\n                    // Check the leading whitespace\n                    {\n                        let originalStartColumn = getFirstNonBlankColumn(originalLine, 1);\n                        let modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);\n                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {\n                            const originalChar = originalLine.charCodeAt(originalStartColumn - 2);\n                            const modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalStartColumn--;\n                            modifiedStartColumn--;\n                        }\n                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);\n                        }\n                    }\n                    // Check the trailing whitespace\n                    {\n                        let originalEndColumn = getLastNonBlankColumn(originalLine, 1);\n                        let modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);\n                        const originalMaxColumn = originalLine.length + 1;\n                        const modifiedMaxColumn = modifiedLine.length + 1;\n                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {\n                            const originalChar = originalLine.charCodeAt(originalEndColumn - 1);\n                            const modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);\n                            if (originalChar !== modifiedChar) {\n                                break;\n                            }\n                            originalEndColumn++;\n                            modifiedEndColumn++;\n                        }\n                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {\n                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);\n                        }\n                    }\n                }\n                originalLineIndex++;\n                modifiedLineIndex++;\n            }\n            if (nextChange) {\n                // Emit the actual change\n                result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));\n                originalLineIndex += nextChange.originalLength;\n                modifiedLineIndex += nextChange.modifiedLength;\n            }\n        }\n        return {\n            quitEarly: quitEarly,\n            changes: result\n        };\n    }\n    _pushTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {\n            // Merged into previous\n            return;\n        }\n        let charChanges = undefined;\n        if (this.shouldComputeCharChanges) {\n            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];\n        }\n        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));\n    }\n    _mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {\n        const len = result.length;\n        if (len === 0) {\n            return false;\n        }\n        const prevChange = result[len - 1];\n        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {\n            // Don't merge with inserts/deletes\n            return false;\n        }\n        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {\n            prevChange.originalEndLineNumber = originalLineNumber;\n            prevChange.modifiedEndLineNumber = modifiedLineNumber;\n            if (this.shouldComputeCharChanges && prevChange.charChanges) {\n                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));\n            }\n            return true;\n        }\n        return false;\n    }\n}\nfunction getFirstNonBlankColumn(txt, defaultValue) {\n    const r = firstNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 1;\n}\nfunction getLastNonBlankColumn(txt, defaultValue) {\n    const r = lastNonWhitespaceIndex(txt);\n    if (r === -1) {\n        return defaultValue;\n    }\n    return r + 2;\n}\nfunction createContinueProcessingPredicate(maximumRuntime) {\n    if (maximumRuntime === 0) {\n        return () => true;\n    }\n    const startTime = Date.now();\n    return () => {\n        return Date.now() - startTime < maximumRuntime;\n    };\n}\n\n// @ts-expect-error no type definition\nvar index = (originalLines, modifiedLines, opts = {}) => {\n    return new DiffComputer(originalLines, modifiedLines, Object.assign({ shouldComputeCharChanges: true, shouldPostProcessCharChanges: true, shouldIgnoreTrimWhitespace: true, shouldMakePrettyDiff: true, maxComputationTime: 5000 }, opts)).computeDiff().changes;\n};\n\nexport { index as default };\n"],"names":["DiffChange","originalStart","originalLength","modifiedStart","modifiedLength","firstNonWhitespaceIndex","str","i","len","chCode","lastNonWhitespaceIndex","startIndex","numberHash","val","initialHashVal","stringHash","s","hashVal","length","Debug","condition","message","MyArray","sourceArray","sourceIndex","destinationArray","destinationIndex","DiffChangeHelper","originalIndex","modifiedIndex","LcsDiff","originalSequence","modifiedSequence","continueProcessingPredicate","originalStringElements","originalElementsOrHash","originalHasStrings","modifiedStringElements","modifiedElementsOrHash","modifiedHasStrings","arr","sequence","elements","hashes","newIndex","originalElement","modifiedElement","index","index1","index2","pretty","originalEnd","modifiedEnd","quitEarlyArr","changes","midOriginalArr","midModifiedArr","result","midOriginal","midModified","leftChanges","rightChanges","diagonalForwardBase","diagonalForwardStart","diagonalForwardEnd","diagonalForwardOffset","diagonalReverseBase","diagonalReverseStart","diagonalReverseEnd","diagonalReverseOffset","forwardPoints","reversePoints","deltaIsEven","forwardChanges","reverseChanges","changeHelper","diagonalMin","diagonalMax","diagonalRelative","lastOriginalIndex","historyIndex","diagonal","originalStartPoint","modifiedStartPoint","lastForwardChange","maxDifferences","numDiagonals","numDifferences","furthestOriginalIndex","furthestModifiedIndex","tempOriginalIndex","matchLengthOfLongest","temp","change","originalStop","modifiedStop","checkOriginal","checkModified","startStrictEqual","mergedChangeArr","prevChange","bestDelta","bestScore","delta","score","aChange","bChange","matchedLength","aOriginalStart","bOriginalEnd","abOriginalLength","aModifiedStart","bModifiedEnd","abModifiedLength","t","originalMatchStart","modifiedMatchStart","desiredLength","originalMax","modifiedMax","bestOriginalStart","bestModifiedStart","j","l","originalScore","modifiedScore","left","right","diagonalBaseIndex","diagonalsBelow","diagonalsAbove","diffEven","lowerBoundEven","upperBoundEven","MINIMUM_MATCHING_CHARACTER_LENGTH","computeDiff","LineSequence","lines","startColumns","endColumns","getFirstNonBlankColumn","getLastNonBlankColumn","shouldIgnoreTrimWhitespace","endIndex","charCodes","lineNumbers","columns","lineContent","startColumn","endColumn","col","CharSequence","CharChange","originalStartLineNumber","originalStartColumn","originalEndLineNumber","originalEndColumn","modifiedStartLineNumber","modifiedStartColumn","modifiedEndLineNumber","modifiedEndColumn","diffChange","originalCharSequence","modifiedCharSequence","postProcessCharChanges","rawChanges","currChange","originalMatchingLength","modifiedMatchingLength","LineChange","charChanges","originalLineSequence","modifiedLineSequence","continueCharDiff","shouldComputeCharChanges","shouldPostProcessCharChanges","DiffComputer","originalLines","modifiedLines","opts","createContinueProcessingPredicate","diffResult","quitEarly","lineChanges","originalLineIndex","modifiedLineIndex","nextChange","originalLine","modifiedLine","originalChar","modifiedChar","originalMaxColumn","modifiedMaxColumn","originalLineNumber","modifiedLineNumber","txt","defaultValue","r","maximumRuntime","startTime"],"mappings":"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","x_google_ignoreList":[0]}