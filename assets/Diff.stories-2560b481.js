import{a as Z,j as P}from"./useStatic-0a5cdcfd.js";import{r as q}from"./index-90fda323.js";import{R as W}from"./textarea-9843bea7.js";class A{constructor(t,e,i,n){this.originalStart=t,this.originalLength=e,this.modifiedStart=i,this.modifiedLength=n}getOriginalEnd(){return this.originalStart+this.originalLength}getModifiedEnd(){return this.modifiedStart+this.modifiedLength}}function V(g){for(let t=0,e=g.length;t<e;t++){const i=g.charCodeAt(t);if(i!==32&&i!==9)return t}return-1}function tt(g,t=g.length-1){for(let e=t;e>=0;e--){const i=g.charCodeAt(e);if(i!==32&&i!==9)return e}return-1}function j(g,t){return(t<<5)-t+g|0}function et(g,t){t=j(149417,t);for(let e=0,i=g.length;e<i;e++)t=j(g.charCodeAt(e),t);return t}class H{static Assert(t,e){if(!t)throw new Error(e)}}class x{static Copy(t,e,i,n,s){for(let l=0;l<s;l++)i[n+l]=t[e+l]}static Copy2(t,e,i,n,s){for(let l=0;l<s;l++)i[n+l]=t[e+l]}}class F{constructor(){this.m_changes=[],this.m_originalStart=1073741824,this.m_modifiedStart=1073741824,this.m_originalCount=0,this.m_modifiedCount=0}MarkNextChange(){(this.m_originalCount>0||this.m_modifiedCount>0)&&this.m_changes.push(new A(this.m_originalStart,this.m_originalCount,this.m_modifiedStart,this.m_modifiedCount)),this.m_originalCount=0,this.m_modifiedCount=0,this.m_originalStart=1073741824,this.m_modifiedStart=1073741824}AddOriginalElement(t,e){this.m_originalStart=Math.min(this.m_originalStart,t),this.m_modifiedStart=Math.min(this.m_modifiedStart,e),this.m_originalCount++}AddModifiedElement(t,e){this.m_originalStart=Math.min(this.m_originalStart,t),this.m_modifiedStart=Math.min(this.m_modifiedStart,e),this.m_modifiedCount++}getChanges(){return(this.m_originalCount>0||this.m_modifiedCount>0)&&this.MarkNextChange(),this.m_changes}getReverseChanges(){return(this.m_originalCount>0||this.m_modifiedCount>0)&&this.MarkNextChange(),this.m_changes.reverse(),this.m_changes}}class w{constructor(t,e,i=null){this.ContinueProcessingPredicate=i,this._originalSequence=t,this._modifiedSequence=e;const[n,s,l]=w._getElements(t),[a,r,o]=w._getElements(e);this._hasStrings=l&&o,this._originalStringElements=n,this._originalElementsOrHash=s,this._modifiedStringElements=a,this._modifiedElementsOrHash=r,this.m_forwardHistory=[],this.m_reverseHistory=[]}static _isStringArray(t){return t.length>0&&typeof t[0]=="string"}static _getElements(t){const e=t.getElements();if(w._isStringArray(e)){const i=new Int32Array(e.length);for(let n=0,s=e.length;n<s;n++)i[n]=et(e[n],0);return[e,i,!0]}return e instanceof Int32Array?[[],e,!1]:[[],new Int32Array(e),!1]}ElementsAreEqual(t,e){return this._originalElementsOrHash[t]!==this._modifiedElementsOrHash[e]?!1:this._hasStrings?this._originalStringElements[t]===this._modifiedStringElements[e]:!0}ElementsAreStrictEqual(t,e){if(!this.ElementsAreEqual(t,e))return!1;const i=w._getStrictElement(this._originalSequence,t),n=w._getStrictElement(this._modifiedSequence,e);return i===n}static _getStrictElement(t,e){return typeof t.getStrictElement=="function"?t.getStrictElement(e):null}OriginalElementsAreEqual(t,e){return this._originalElementsOrHash[t]!==this._originalElementsOrHash[e]?!1:this._hasStrings?this._originalStringElements[t]===this._originalStringElements[e]:!0}ModifiedElementsAreEqual(t,e){return this._modifiedElementsOrHash[t]!==this._modifiedElementsOrHash[e]?!1:this._hasStrings?this._modifiedStringElements[t]===this._modifiedStringElements[e]:!0}ComputeDiff(t){return this._ComputeDiff(0,this._originalElementsOrHash.length-1,0,this._modifiedElementsOrHash.length-1,t)}_ComputeDiff(t,e,i,n,s){const l=[!1];let a=this.ComputeDiffRecursive(t,e,i,n,l);return s&&(a=this.PrettifyChanges(a)),{quitEarly:l[0],changes:a}}ComputeDiffRecursive(t,e,i,n,s){for(s[0]=!1;t<=e&&i<=n&&this.ElementsAreEqual(t,i);)t++,i++;for(;e>=t&&n>=i&&this.ElementsAreEqual(e,n);)e--,n--;if(t>e||i>n){let h;return i<=n?(H.Assert(t===e+1,"originalStart should only be one more than originalEnd"),h=[new A(t,0,i,n-i+1)]):t<=e?(H.Assert(i===n+1,"modifiedStart should only be one more than modifiedEnd"),h=[new A(t,e-t+1,i,0)]):(H.Assert(t===e+1,"originalStart should only be one more than originalEnd"),H.Assert(i===n+1,"modifiedStart should only be one more than modifiedEnd"),h=[]),h}const l=[0],a=[0],r=this.ComputeRecursionPoint(t,e,i,n,l,a,s),o=l[0],m=a[0];if(r!==null)return r;if(!s[0]){const h=this.ComputeDiffRecursive(t,o,i,m,s);let u=[];return s[0]?u=[new A(o+1,e-(o+1)+1,m+1,n-(m+1)+1)]:u=this.ComputeDiffRecursive(o+1,e,m+1,n,s),this.ConcatenateChanges(h,u)}return[new A(t,e-t+1,i,n-i+1)]}WALKTRACE(t,e,i,n,s,l,a,r,o,m,h,u,d,f,C,S,E,b){let p=null,T=null,N=new F,O=e,M=i,L=d[0]-S[0]-n,y=-1073741824,v=this.m_forwardHistory.length-1;do{const _=L+t;_===O||_<M&&o[_-1]<o[_+1]?(h=o[_+1],f=h-L-n,h<y&&N.MarkNextChange(),y=h,N.AddModifiedElement(h+1,f),L=_+1-t):(h=o[_-1]+1,f=h-L-n,h<y&&N.MarkNextChange(),y=h-1,N.AddOriginalElement(h,f+1),L=_-1-t),v>=0&&(o=this.m_forwardHistory[v],t=o[0],O=1,M=o.length-1)}while(--v>=-1);if(p=N.getReverseChanges(),b[0]){let _=d[0]+1,c=S[0]+1;if(p!==null&&p.length>0){const D=p[p.length-1];_=Math.max(_,D.getOriginalEnd()),c=Math.max(c,D.getModifiedEnd())}T=[new A(_,u-_+1,c,C-c+1)]}else{N=new F,O=l,M=a,L=d[0]-S[0]-r,y=1073741824,v=E?this.m_reverseHistory.length-1:this.m_reverseHistory.length-2;do{const _=L+s;_===O||_<M&&m[_-1]>=m[_+1]?(h=m[_+1]-1,f=h-L-r,h>y&&N.MarkNextChange(),y=h+1,N.AddOriginalElement(h+1,f+1),L=_+1-s):(h=m[_-1],f=h-L-r,h>y&&N.MarkNextChange(),y=h,N.AddModifiedElement(h+1,f+1),L=_-1-s),v>=0&&(m=this.m_reverseHistory[v],s=m[0],O=1,M=m.length-1)}while(--v>=-1);T=N.getChanges()}return this.ConcatenateChanges(p,T)}ComputeRecursionPoint(t,e,i,n,s,l,a){let r=0,o=0,m=0,h=0,u=0,d=0;t--,i--,s[0]=0,l[0]=0,this.m_forwardHistory=[],this.m_reverseHistory=[];const f=e-t+(n-i),C=f+1,S=new Int32Array(C),E=new Int32Array(C),b=n-i,p=e-t,T=t-i,N=e-n,M=(p-b)%2===0;S[b]=t,E[p]=e,a[0]=!1;for(let L=1;L<=f/2+1;L++){let y=0,v=0;m=this.ClipDiagonalBound(b-L,L,b,C),h=this.ClipDiagonalBound(b+L,L,b,C);for(let c=m;c<=h;c+=2){c===m||c<h&&S[c-1]<S[c+1]?r=S[c+1]:r=S[c-1]+1,o=r-(c-b)-T;const D=r;for(;r<e&&o<n&&this.ElementsAreEqual(r+1,o+1);)r++,o++;if(S[c]=r,r+o>y+v&&(y=r,v=o),!M&&Math.abs(c-p)<=L-1&&r>=E[c])return s[0]=r,l[0]=o,D<=E[c]&&1447>0&&L<=1447+1?this.WALKTRACE(b,m,h,T,p,u,d,N,S,E,r,e,s,o,n,l,M,a):null}const _=(y-t+(v-i)-L)/2;if(this.ContinueProcessingPredicate!==null&&!this.ContinueProcessingPredicate(y,_))return a[0]=!0,s[0]=y,l[0]=v,_>0&&1447>0&&L<=1447+1?this.WALKTRACE(b,m,h,T,p,u,d,N,S,E,r,e,s,o,n,l,M,a):(t++,i++,[new A(t,e-t+1,i,n-i+1)]);u=this.ClipDiagonalBound(p-L,L,p,C),d=this.ClipDiagonalBound(p+L,L,p,C);for(let c=u;c<=d;c+=2){c===u||c<d&&E[c-1]>=E[c+1]?r=E[c+1]-1:r=E[c-1],o=r-(c-p)-N;const D=r;for(;r>t&&o>i&&this.ElementsAreEqual(r,o);)r--,o--;if(E[c]=r,M&&Math.abs(c-b)<=L&&r<=S[c])return s[0]=r,l[0]=o,D>=S[c]&&1447>0&&L<=1447+1?this.WALKTRACE(b,m,h,T,p,u,d,N,S,E,r,e,s,o,n,l,M,a):null}if(L<=1447){let c=new Int32Array(h-m+2);c[0]=b-m+1,x.Copy2(S,m,c,1,h-m+1),this.m_forwardHistory.push(c),c=new Int32Array(d-u+2),c[0]=p-u+1,x.Copy2(E,u,c,1,d-u+1),this.m_reverseHistory.push(c)}}return this.WALKTRACE(b,m,h,T,p,u,d,N,S,E,r,e,s,o,n,l,M,a)}PrettifyChanges(t){for(let e=0;e<t.length;e++){const i=t[e],n=e<t.length-1?t[e+1].originalStart:this._originalElementsOrHash.length,s=e<t.length-1?t[e+1].modifiedStart:this._modifiedElementsOrHash.length,l=i.originalLength>0,a=i.modifiedLength>0;for(;i.originalStart+i.originalLength<n&&i.modifiedStart+i.modifiedLength<s&&(!l||this.OriginalElementsAreEqual(i.originalStart,i.originalStart+i.originalLength))&&(!a||this.ModifiedElementsAreEqual(i.modifiedStart,i.modifiedStart+i.modifiedLength));){const o=this.ElementsAreStrictEqual(i.originalStart,i.modifiedStart);if(this.ElementsAreStrictEqual(i.originalStart+i.originalLength,i.modifiedStart+i.modifiedLength)&&!o)break;i.originalStart++,i.modifiedStart++}let r=[null];if(e<t.length-1&&this.ChangesOverlap(t[e],t[e+1],r)){t[e]=r[0],t.splice(e+1,1),e--;continue}}for(let e=t.length-1;e>=0;e--){const i=t[e];let n=0,s=0;if(e>0){const h=t[e-1];n=h.originalStart+h.originalLength,s=h.modifiedStart+h.modifiedLength}const l=i.originalLength>0,a=i.modifiedLength>0;let r=0,o=this._boundaryScore(i.originalStart,i.originalLength,i.modifiedStart,i.modifiedLength);for(let h=1;;h++){const u=i.originalStart-h,d=i.modifiedStart-h;if(u<n||d<s||l&&!this.OriginalElementsAreEqual(u,u+i.originalLength)||a&&!this.ModifiedElementsAreEqual(d,d+i.modifiedLength))break;const C=(u===n&&d===s?5:0)+this._boundaryScore(u,i.originalLength,d,i.modifiedLength);C>o&&(o=C,r=h)}i.originalStart-=r,i.modifiedStart-=r;const m=[null];if(e>0&&this.ChangesOverlap(t[e-1],t[e],m)){t[e-1]=m[0],t.splice(e,1),e++;continue}}if(this._hasStrings)for(let e=1,i=t.length;e<i;e++){const n=t[e-1],s=t[e],l=s.originalStart-n.originalStart-n.originalLength,a=n.originalStart,r=s.originalStart+s.originalLength,o=r-a,m=n.modifiedStart,h=s.modifiedStart+s.modifiedLength,u=h-m;if(l<5&&o<20&&u<20){const d=this._findBetterContiguousSequence(a,o,m,u,l);if(d){const[f,C]=d;(f!==n.originalStart+n.originalLength||C!==n.modifiedStart+n.modifiedLength)&&(n.originalLength=f-n.originalStart,n.modifiedLength=C-n.modifiedStart,s.originalStart=f+l,s.modifiedStart=C+l,s.originalLength=r-s.originalStart,s.modifiedLength=h-s.modifiedStart)}}}return t}_findBetterContiguousSequence(t,e,i,n,s){if(e<s||n<s)return null;const l=t+e-s+1,a=i+n-s+1;let r=0,o=0,m=0;for(let h=t;h<l;h++)for(let u=i;u<a;u++){const d=this._contiguousSequenceScore(h,u,s);d>0&&d>r&&(r=d,o=h,m=u)}return r>0?[o,m]:null}_contiguousSequenceScore(t,e,i){let n=0;for(let s=0;s<i;s++){if(!this.ElementsAreEqual(t+s,e+s))return 0;n+=this._originalStringElements[t+s].length}return n}_OriginalIsBoundary(t){return t<=0||t>=this._originalElementsOrHash.length-1?!0:this._hasStrings&&/^\s*$/.test(this._originalStringElements[t])}_OriginalRegionIsBoundary(t,e){if(this._OriginalIsBoundary(t)||this._OriginalIsBoundary(t-1))return!0;if(e>0){const i=t+e;if(this._OriginalIsBoundary(i-1)||this._OriginalIsBoundary(i))return!0}return!1}_ModifiedIsBoundary(t){return t<=0||t>=this._modifiedElementsOrHash.length-1?!0:this._hasStrings&&/^\s*$/.test(this._modifiedStringElements[t])}_ModifiedRegionIsBoundary(t,e){if(this._ModifiedIsBoundary(t)||this._ModifiedIsBoundary(t-1))return!0;if(e>0){const i=t+e;if(this._ModifiedIsBoundary(i-1)||this._ModifiedIsBoundary(i))return!0}return!1}_boundaryScore(t,e,i,n){const s=this._OriginalRegionIsBoundary(t,e)?1:0,l=this._ModifiedRegionIsBoundary(i,n)?1:0;return s+l}ConcatenateChanges(t,e){let i=[];if(t.length===0||e.length===0)return e.length>0?e:t;if(this.ChangesOverlap(t[t.length-1],e[0],i)){const n=new Array(t.length+e.length-1);return x.Copy(t,0,n,0,t.length-1),n[t.length-1]=i[0],x.Copy(e,1,n,t.length,e.length-1),n}else{const n=new Array(t.length+e.length);return x.Copy(t,0,n,0,t.length),x.Copy(e,0,n,t.length,e.length),n}}ChangesOverlap(t,e,i){if(H.Assert(t.originalStart<=e.originalStart,"Left change is not less than or equal to right change"),H.Assert(t.modifiedStart<=e.modifiedStart,"Left change is not less than or equal to right change"),t.originalStart+t.originalLength>=e.originalStart||t.modifiedStart+t.modifiedLength>=e.modifiedStart){const n=t.originalStart;let s=t.originalLength;const l=t.modifiedStart;let a=t.modifiedLength;return t.originalStart+t.originalLength>=e.originalStart&&(s=e.originalStart+e.originalLength-t.originalStart),t.modifiedStart+t.modifiedLength>=e.modifiedStart&&(a=e.modifiedStart+e.modifiedLength-t.modifiedStart),i[0]=new A(n,s,l,a),!0}else return i[0]=null,!1}ClipDiagonalBound(t,e,i,n){if(t>=0&&t<n)return t;const s=i,l=n-i-1,a=e%2===0;if(t<0){const r=s%2===0;return a===r?0:1}else{const r=l%2===0;return a===r?n-1:n-2}}}const it=3;function Y(g,t,e,i){return new w(g,t,e).ComputeDiff(i)}class K{constructor(t){const e=[],i=[];for(let n=0,s=t.length;n<s;n++)e[n]=z(t[n],1),i[n]=I(t[n],1);this.lines=t,this._startColumns=e,this._endColumns=i}getElements(){const t=[];for(let e=0,i=this.lines.length;e<i;e++)t[e]=this.lines[e].substring(this._startColumns[e]-1,this._endColumns[e]-1);return t}getStrictElement(t){return this.lines[t]}getStartLineNumber(t){return t+1}getEndLineNumber(t){return t+1}createCharSequence(t,e,i){const n=[],s=[],l=[];let a=0;for(let r=e;r<=i;r++){const o=this.lines[r],m=t?this._startColumns[r]:1,h=t?this._endColumns[r]:o.length+1;for(let u=m;u<h;u++)n[a]=o.charCodeAt(u-1),s[a]=r+1,l[a]=u,a++}return new nt(n,s,l)}}class nt{constructor(t,e,i){this._charCodes=t,this._lineNumbers=e,this._columns=i}getElements(){return this._charCodes}getStartLineNumber(t){return this._lineNumbers[t]}getStartColumn(t){return this._columns[t]}getEndLineNumber(t){return this._lineNumbers[t]}getEndColumn(t){return this._columns[t]+1}}class k{constructor(t,e,i,n,s,l,a,r){this.originalStartLineNumber=t,this.originalStartColumn=e,this.originalEndLineNumber=i,this.originalEndColumn=n,this.modifiedStartLineNumber=s,this.modifiedStartColumn=l,this.modifiedEndLineNumber=a,this.modifiedEndColumn=r}static createFromDiffChange(t,e,i){let n,s,l,a,r,o,m,h;return t.originalLength===0?(n=0,s=0,l=0,a=0):(n=e.getStartLineNumber(t.originalStart),s=e.getStartColumn(t.originalStart),l=e.getEndLineNumber(t.originalStart+t.originalLength-1),a=e.getEndColumn(t.originalStart+t.originalLength-1)),t.modifiedLength===0?(r=0,o=0,m=0,h=0):(r=i.getStartLineNumber(t.modifiedStart),o=i.getStartColumn(t.modifiedStart),m=i.getEndLineNumber(t.modifiedStart+t.modifiedLength-1),h=i.getEndColumn(t.modifiedStart+t.modifiedLength-1)),new k(n,s,l,a,r,o,m,h)}}function rt(g){if(g.length<=1)return g;const t=[g[0]];let e=t[0];for(let i=1,n=g.length;i<n;i++){const s=g[i],l=s.originalStart-(e.originalStart+e.originalLength),a=s.modifiedStart-(e.modifiedStart+e.modifiedLength);Math.min(l,a)<it?(e.originalLength=s.originalStart+s.originalLength-e.originalStart,e.modifiedLength=s.modifiedStart+s.modifiedLength-e.modifiedStart):(t.push(s),e=s)}return t}class R{constructor(t,e,i,n,s){this.originalStartLineNumber=t,this.originalEndLineNumber=e,this.modifiedStartLineNumber=i,this.modifiedEndLineNumber=n,this.charChanges=s}static createFromDiffResult(t,e,i,n,s,l,a){let r,o,m,h,u;if(e.originalLength===0?(r=i.getStartLineNumber(e.originalStart)-1,o=0):(r=i.getStartLineNumber(e.originalStart),o=i.getEndLineNumber(e.originalStart+e.originalLength-1)),e.modifiedLength===0?(m=n.getStartLineNumber(e.modifiedStart)-1,h=0):(m=n.getStartLineNumber(e.modifiedStart),h=n.getEndLineNumber(e.modifiedStart+e.modifiedLength-1)),l&&e.originalLength>0&&e.originalLength<20&&e.modifiedLength>0&&e.modifiedLength<20&&s()){const d=i.createCharSequence(t,e.originalStart,e.originalStart+e.originalLength-1),f=n.createCharSequence(t,e.modifiedStart,e.modifiedStart+e.modifiedLength-1);let C=Y(d,f,s,!0).changes;a&&(C=rt(C)),u=[];for(let S=0,E=C.length;S<E;S++)u.push(k.createFromDiffChange(C[S],d,f))}return new R(r,o,m,h,u)}}class st{constructor(t,e,i){this.shouldComputeCharChanges=i.shouldComputeCharChanges,this.shouldPostProcessCharChanges=i.shouldPostProcessCharChanges,this.shouldIgnoreTrimWhitespace=i.shouldIgnoreTrimWhitespace,this.shouldMakePrettyDiff=i.shouldMakePrettyDiff,this.originalLines=t,this.modifiedLines=e,this.original=new K(t),this.modified=new K(e),this.continueLineDiff=$(i.maxComputationTime),this.continueCharDiff=$(i.maxComputationTime===0?0:Math.min(i.maxComputationTime,5e3))}computeDiff(){if(this.original.lines.length===1&&this.original.lines[0].length===0)return this.modified.lines.length===1&&this.modified.lines[0].length===0?{quitEarly:!1,changes:[]}:{quitEarly:!1,changes:[{originalStartLineNumber:1,originalEndLineNumber:1,modifiedStartLineNumber:1,modifiedEndLineNumber:this.modified.lines.length,charChanges:[{modifiedEndColumn:0,modifiedEndLineNumber:0,modifiedStartColumn:0,modifiedStartLineNumber:0,originalEndColumn:0,originalEndLineNumber:0,originalStartColumn:0,originalStartLineNumber:0}]}]};if(this.modified.lines.length===1&&this.modified.lines[0].length===0)return{quitEarly:!1,changes:[{originalStartLineNumber:1,originalEndLineNumber:this.original.lines.length,modifiedStartLineNumber:1,modifiedEndLineNumber:1,charChanges:[{modifiedEndColumn:0,modifiedEndLineNumber:0,modifiedStartColumn:0,modifiedStartLineNumber:0,originalEndColumn:0,originalEndLineNumber:0,originalStartColumn:0,originalStartLineNumber:0}]}]};const t=Y(this.original,this.modified,this.continueLineDiff,this.shouldMakePrettyDiff),e=t.changes,i=t.quitEarly;if(this.shouldIgnoreTrimWhitespace){const a=[];for(let r=0,o=e.length;r<o;r++)a.push(R.createFromDiffResult(this.shouldIgnoreTrimWhitespace,e[r],this.original,this.modified,this.continueCharDiff,this.shouldComputeCharChanges,this.shouldPostProcessCharChanges));return{quitEarly:i,changes:a}}const n=[];let s=0,l=0;for(let a=-1,r=e.length;a<r;a++){const o=a+1<r?e[a+1]:null,m=o?o.originalStart:this.originalLines.length,h=o?o.modifiedStart:this.modifiedLines.length;for(;s<m&&l<h;){const u=this.originalLines[s],d=this.modifiedLines[l];if(u!==d){{let f=z(u,1),C=z(d,1);for(;f>1&&C>1;){const S=u.charCodeAt(f-2),E=d.charCodeAt(C-2);if(S!==E)break;f--,C--}(f>1||C>1)&&this._pushTrimWhitespaceCharChange(n,s+1,1,f,l+1,1,C)}{let f=I(u,1),C=I(d,1);const S=u.length+1,E=d.length+1;for(;f<S&&C<E;){const b=u.charCodeAt(f-1),p=u.charCodeAt(C-1);if(b!==p)break;f++,C++}(f<S||C<E)&&this._pushTrimWhitespaceCharChange(n,s+1,f,S,l+1,C,E)}}s++,l++}o&&(n.push(R.createFromDiffResult(this.shouldIgnoreTrimWhitespace,o,this.original,this.modified,this.continueCharDiff,this.shouldComputeCharChanges,this.shouldPostProcessCharChanges)),s+=o.originalLength,l+=o.modifiedLength)}return{quitEarly:i,changes:n}}_pushTrimWhitespaceCharChange(t,e,i,n,s,l,a){if(this._mergeTrimWhitespaceCharChange(t,e,i,n,s,l,a))return;let r;this.shouldComputeCharChanges&&(r=[new k(e,i,e,n,s,l,s,a)]),t.push(new R(e,e,s,s,r))}_mergeTrimWhitespaceCharChange(t,e,i,n,s,l,a){const r=t.length;if(r===0)return!1;const o=t[r-1];return o.originalEndLineNumber===0||o.modifiedEndLineNumber===0?!1:o.originalEndLineNumber+1===e&&o.modifiedEndLineNumber+1===s?(o.originalEndLineNumber=e,o.modifiedEndLineNumber=s,this.shouldComputeCharChanges&&o.charChanges&&o.charChanges.push(new k(e,i,e,n,s,l,s,a)),!0):!1}}function z(g,t){const e=V(g);return e===-1?t:e+1}function I(g,t){const e=tt(g);return e===-1?t:e+2}function $(g){if(g===0)return()=>!0;const t=Date.now();return()=>Date.now()-t<g}var ot=(g,t,e={})=>new st(g,t,Object.assign({shouldComputeCharChanges:!0,shouldPostProcessCharChanges:!0,shouldIgnoreTrimWhitespace:!0,shouldMakePrettyDiff:!0,maxComputationTime:5e3},e)).computeDiff().changes;const ut={component:W},G={width:"300px",height:"400px"},U=(g,t)=>e=>{var l;const i=Array.from({length:e.length}),n=Array.from({length:e.length});for(const a of g){for(let r=a.originalStartLineNumber;r<=a.originalEndLineNumber;r++)i[r-1]||(i[r-1]=[]),a.modifiedEndLineNumber===0&&i[r-1].push({start:void 0,end:void 0});for(let r=a.modifiedStartLineNumber;r<=a.modifiedEndLineNumber;r++)n[r-1]||(n[r-1]=[]),a.originalEndLineNumber===0&&n[r-1].push({start:void 0,end:void 0});(l=a.charChanges)==null||l.forEach(r=>{for(let o=r.originalStartLineNumber;o<=r.originalEndLineNumber;o++)o===r.originalStartLineNumber?r.originalStartLineNumber===r.originalEndLineNumber?(i[o-1]||(i[o-1]=[])).push({start:r.originalStartColumn,end:r.originalEndColumn}):(i[o-1]||(i[o-1]=[])).push({start:r.originalStartColumn,end:void 0}):o===r.originalEndLineNumber?(i[o-1]||(i[o-1]=[])).push({start:void 0,end:r.originalEndColumn}):(i[o-1]||(i[o-1]=[])).push({start:void 0,end:void 0});for(let o=r.modifiedStartLineNumber;o<=r.modifiedEndLineNumber;o++)o===r.modifiedStartLineNumber?r.modifiedStartLineNumber===r.modifiedEndLineNumber?(n[o-1]||(n[o-1]=[])).push({start:r.modifiedStartColumn,end:r.modifiedEndColumn}):(n[o-1]||(n[o-1]=[])).push({start:r.modifiedStartColumn,end:void 0}):o===r.modifiedEndLineNumber?(n[o-1]||(n[o-1]=[])).push({start:void 0,end:r.modifiedEndColumn}):(n[o-1]||(n[o-1]=[])).push({start:void 0,end:void 0})})}const s=t==="base"?{background:"rgba(255, 0, 0, 0.2)"}:{background:"rgba(155, 185, 85, 0.2)"};return e.split(`
`).map((a,r)=>{const o=t==="base"&&i[r]||t==="target"&&n[r]||void 0;let m=[a];if(o&&o.length){let h=0;const u=[];for(let d=0;d<o.length;d++){const f=o[d],C=f.start?f.start-1:0,S=f.end?f.end-1:a.length;u.push(a.slice(h,C)),u.push(P("span",{style:s,children:a.slice(C,S)},`${r}-${d}`)),h=S}u.push(a.slice(h)),m=u}return m.push(" "),P("div",{style:o&&s,children:m},r)})},B={render:()=>{const[g,t]=q.useState(`This line is removed on the right.
just some text
abcd
efgh
Some more text
Some more text
Some more text`),[e,i]=q.useState(`just some text
abcz
zzzzefgh
Some more text.
This line is removed on the left.`),n=q.useMemo(()=>ot(g.split(`
`),e.split(`
`)),[g,e]);return Z("div",{children:[P(W,{style:G,onChange:s=>t(s.target.value),value:g,children:U(n,"base")}),P(W,{style:G,onChange:s=>i(s.target.value),value:e,children:U(n,"target")})]})}};var J,Q,X;B.parameters={...B.parameters,docs:{...(J=B.parameters)==null?void 0:J.docs,source:{originalSource:`{
  render: () => {
    const [baseText, setBaseText] = useState("This line is removed on the right.\\njust some text\\nabcd\\nefgh\\nSome more text\\nSome more text\\nSome more text");
    const [targetText, setTargetText] = useState("just some text\\nabcz\\nzzzzefgh\\nSome more text.\\nThis line is removed on the left.");
    const tokens = useMemo(() => diff(baseText.split("\\n"), targetText.split("\\n")), [baseText, targetText]);
    return <div>
        <RichTextarea style={style} onChange={e => setBaseText(e.target.value)} value={baseText}>
          {createDiffRenderer(tokens, "base")}
        </RichTextarea>
        <RichTextarea style={style} onChange={e => setTargetText(e.target.value)} value={targetText}>
          {createDiffRenderer(tokens, "target")}
        </RichTextarea>
      </div>;
  }
}`,...(X=(Q=B.parameters)==null?void 0:Q.docs)==null?void 0:X.source}}};const mt=["Diff"];export{B as Diff,mt as __namedExportsOrder,ut as default};
//# sourceMappingURL=Diff.stories-2560b481.js.map
