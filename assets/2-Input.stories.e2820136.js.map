{"version":3,"file":"2-Input.stories.e2820136.js","sources":["../../src/input.tsx","../../stories/basics/2-Input.stories.tsx"],"sourcesContent":["import {\n  useEffect,\n  useRef,\n  useState,\n  useMemo,\n  useCallback,\n  forwardRef,\n  useImperativeHandle,\n  useLayoutEffect,\n} from \"react\";\nimport { useSyncExternalStore } from \"use-sync-external-store/shim\";\n// @ts-expect-error no type definition\nimport rangeAtIndex from \"range-at-index\";\nimport type { Renderer } from \"./renderers\";\nimport {\n  dispatchClonedMouseEvent,\n  dispatchMouseMoveEvent,\n  dispatchMouseOutEvent,\n  getHorizontalPadding,\n  getPointedElement,\n  getStyle,\n  getVerticalPadding,\n  isSafari,\n  stopPropagation,\n  syncBackdropStyle,\n} from \"./dom\";\nimport { initSelectionStore } from \"./selection\";\n\n// for caret position detection\nconst CARET_DETECTOR = <span style={{ color: \"transparent\" }}>{\"\\u200b\"}</span>;\n\nexport type CaretPosition =\n  | {\n      focused: false;\n      selectionStart: number;\n      selectionEnd: number;\n    }\n  | {\n      focused: true;\n      selectionStart: number;\n      selectionEnd: number;\n      top: number;\n      left: number;\n      height: number;\n    };\n\nexport type RichInputHandle = HTMLInputElement;\n\nexport type RichInputProps = Omit<\n  JSX.IntrinsicElements[\"input\"],\n  \"value\" | \"defaultValue\" | \"children\"\n> & {\n  value: string;\n  children?: Renderer;\n  autoHeight?: boolean;\n  onSelectionChange?: (pos: CaretPosition, value: string) => void;\n};\n\nexport const RichInput = forwardRef<RichInputHandle, RichInputProps>(\n  (\n    {\n      children: render,\n      value,\n      autoHeight,\n      style,\n      onScroll,\n      onInput,\n      onCompositionStart,\n      onCompositionUpdate,\n      onCompositionEnd,\n      onKeyDown,\n      onClick,\n      onMouseDown,\n      onMouseUp,\n      onMouseMove,\n      onMouseLeave,\n      onFocus,\n      onBlur,\n      onSelectionChange,\n      ...props\n    },\n    propRef\n  ): React.ReactElement => {\n    const textAreaRef = useRef<HTMLInputElement>(null);\n    const backdropRef = useRef<HTMLDivElement>(null);\n    const [[left, top], setPos] = useState<[left: number, top: number]>([0, 0]);\n    const [[width, height, hPadding, vPadding], setRect] = useState<\n      [width: number, height: number, hPadding: number, vPadding: number]\n    >([0, 0, 0, 0]);\n    const [focused, setFocused] = useState<boolean>(false);\n\n    const caretColorRef = useRef(\"\");\n    const pointedRef = useRef<HTMLElement | null>(null);\n\n    const selectionStore = useState(() => initSelectionStore(textAreaRef))[0];\n    const [selectionStart, selectionEnd] = useSyncExternalStore(\n      selectionStore._subscribe,\n      selectionStore._getSelection\n    );\n\n    const totalWidth = width + hPadding;\n    const totalHeight = height + vPadding;\n\n    useImperativeHandle(\n      propRef,\n      () => {\n        const el = textAreaRef.current!;\n        const overrides = {\n          get selectionStart() {\n            const sel = selectionStore._getSelectionStart();\n            if (sel == null) {\n              return 0;\n            } else {\n              return sel;\n            }\n          },\n          get selectionEnd() {\n            const sel = selectionStore._getSelectionEnd();\n            if (sel == null) {\n              return 0;\n            } else {\n              return sel;\n            }\n          },\n          setSelectionRange(\n            ...args: Parameters<HTMLInputElement[\"setSelectionRange\"]>\n          ) {\n            el.focus();\n            el.setSelectionRange(...args);\n          },\n          setRangeText(\n            text: string,\n            start: number,\n            end: number,\n            preserve?: SelectionMode\n          ) {\n            if (el.setRangeText) {\n              el.setRangeText(text, start, end, preserve);\n            } else {\n              el.focus();\n              el.selectionStart = start;\n              el.selectionEnd = end;\n              document.execCommand(\"insertText\", false, text);\n            }\n            // Invoke onChange to lift state up\n            el.dispatchEvent(new Event(\"input\", { bubbles: true }));\n          },\n        };\n\n        return new Proxy(el, {\n          get(target, prop: keyof HTMLInputElement) {\n            if ((overrides as any)[prop]) {\n              return (overrides as any)[prop];\n            }\n            const value = target[prop];\n            return typeof value === \"function\" ? value.bind(target) : value;\n          },\n        }) as HTMLInputElement;\n      },\n      [textAreaRef]\n    );\n\n    useLayoutEffect(() => {\n      const textarea = textAreaRef.current;\n      if (!textarea) return;\n      const observer = new ResizeObserver(([entry]) => {\n        const { contentRect, borderBoxSize } = entry!;\n        if (borderBoxSize && borderBoxSize[0]) {\n          setRect([\n            contentRect.width,\n            contentRect.height,\n            borderBoxSize[0].inlineSize - contentRect.width,\n            borderBoxSize[0].blockSize - contentRect.height,\n          ]);\n          return;\n        }\n        const style = getStyle(textarea);\n        setRect([\n          contentRect.width,\n          contentRect.height,\n          getHorizontalPadding(style),\n          getVerticalPadding(style),\n        ]);\n      });\n      observer.observe(textarea);\n      return () => {\n        observer.disconnect();\n      };\n    }, []);\n\n    useLayoutEffect(() => {\n      // Sync backdrop style\n      const textarea = textAreaRef.current;\n      const backdrop = backdropRef.current;\n      if (!backdrop || !textarea) return;\n      syncBackdropStyle(textarea, backdrop, caretColorRef, style);\n    }, [style]);\n\n    useEffect(() => {\n      if (selectionStart == null || selectionEnd == null || !onSelectionChange)\n        return;\n      if (!focused) {\n        onSelectionChange(\n          {\n            focused: false,\n            selectionStart: selectionStart,\n            selectionEnd: selectionEnd,\n          },\n          value\n        );\n      } else {\n        const range = rangeAtIndex(\n          backdropRef.current,\n          selectionStart,\n          selectionStart + 1\n        ) as Range;\n        const rect = range.getBoundingClientRect();\n        onSelectionChange(\n          {\n            focused: true,\n            top: rect.top,\n            left: rect.left,\n            height: rect.height,\n            selectionStart: selectionStart,\n            selectionEnd: selectionEnd,\n          },\n          value\n        );\n      }\n    }, [focused, selectionStart, selectionEnd]);\n\n    useEffect(() => {\n      if (!isSafari()) return;\n\n      // FIXME: Safari does not fire scroll event on input so substitute with pseudo selection change event\n      return selectionStore._subscribe(() => {\n        const el = textAreaRef.current;\n        if (!el) return;\n        setPos([el.scrollLeft, el.scrollTop]);\n      });\n    }, []);\n\n    useEffect(() => {\n      const textarea = textAreaRef.current;\n      if (!autoHeight || !textarea) return;\n      textarea.style.height = \"auto\";\n      textarea.style.height = `${textarea.scrollHeight}px`;\n    });\n\n    return (\n      <div\n        style={useMemo(\n          (): React.CSSProperties => ({\n            display: \"inline-block\",\n            position: \"relative\",\n            width: totalWidth,\n            height: totalHeight,\n          }),\n          [totalWidth, totalHeight]\n        )}\n      >\n        <div\n          style={useMemo((): React.CSSProperties => {\n            const s: React.CSSProperties = {\n              position: \"absolute\",\n              overflow: \"hidden\",\n              top: 0,\n              left: 0,\n              width: totalWidth,\n              height: totalHeight,\n            };\n            if (!style) return s;\n            ([\"background\", \"backgroundColor\"] as const).forEach((k) => {\n              if (style[k]) s[k] = style[k] as any;\n            });\n            return s;\n          }, [totalWidth, totalHeight, style])}\n        >\n          <div\n            ref={backdropRef}\n            aria-hidden\n            // Stop propagation of events dispatched on backdrop\n            onClick={stopPropagation}\n            onMouseDown={stopPropagation}\n            onMouseUp={stopPropagation}\n            onMouseOver={stopPropagation}\n            onMouseOut={stopPropagation}\n            onMouseMove={stopPropagation}\n          >\n            <div style={{ width, height, overflow: \"hidden\" }}>\n              <div\n                style={useMemo(\n                  (): React.CSSProperties => ({\n                    transform: `translate(${-left}px, ${-top}px)`,\n                    pointerEvents: \"none\",\n                    userSelect: \"none\",\n                    msUserSelect: \"none\",\n                    WebkitUserSelect: \"none\",\n                    // https://stackoverflow.com/questions/2545542/font-size-rendering-inconsistencies-on-an-iphone\n                    textSizeAdjust: \"100%\",\n                    WebkitTextSizeAdjust: \"100%\",\n                    whiteSpace: \"pre\",\n                  }),\n                  [left, top]\n                )}\n              >\n                {useMemo(\n                  () => (render ? render(value) : value),\n                  [value, render]\n                )}\n                {CARET_DETECTOR}\n              </div>\n            </div>\n          </div>\n        </div>\n        <input\n          {...props}\n          ref={textAreaRef}\n          value={value}\n          style={useMemo(\n            () => ({\n              ...style,\n              background: \"transparent\",\n              margin: 0,\n              // Fixed bug that sometimes texts disappear in Chrome for unknown reason\n              position: \"absolute\",\n            }),\n            [style]\n          )}\n          onScroll={useCallback(\n            (e: React.UIEvent<HTMLInputElement>) => {\n              setPos([e.currentTarget.scrollLeft, e.currentTarget.scrollTop]);\n              onScroll?.(e);\n            },\n            [onScroll]\n          )}\n          onInput={useCallback(\n            (e: React.FormEvent<HTMLInputElement>) => {\n              onInput?.(e);\n              selectionStore._update();\n            },\n            [onInput]\n          )}\n          onCompositionStart={useCallback(\n            (e: React.CompositionEvent<HTMLInputElement>) => {\n              selectionStore._setComposition(e.nativeEvent);\n              onCompositionStart?.(e);\n            },\n            [onCompositionStart]\n          )}\n          onCompositionUpdate={useCallback(\n            (e: React.CompositionEvent<HTMLInputElement>) => {\n              selectionStore._setComposition(e.nativeEvent);\n              onCompositionUpdate?.(e);\n            },\n            [onCompositionUpdate]\n          )}\n          onCompositionEnd={useCallback(\n            (e: React.CompositionEvent<HTMLInputElement>) => {\n              selectionStore._setComposition(null);\n              onCompositionEnd?.(e);\n            },\n            [onCompositionEnd]\n          )}\n          onKeyDown={useCallback(\n            (e: React.KeyboardEvent<HTMLInputElement>) => {\n              // Ignore keydown events during IME composition.\n              // Safari sometimes fires keydown event after compositionend so also ignore it.\n              // https://developer.mozilla.org/en-US/docs/Web/API/Document/keydown_event#ignoring_keydown_during_ime_composition\n              if (e.nativeEvent.isComposing || e.nativeEvent.keyCode === 229) {\n                return;\n              }\n\n              onKeyDown?.(e);\n              selectionStore._update();\n            },\n            [onKeyDown]\n          )}\n          onClick={useCallback(\n            (e: React.MouseEvent<HTMLInputElement>) => {\n              onClick?.(e);\n              const textarea = textAreaRef.current;\n              const backdrop = backdropRef.current;\n              if (!textarea || !backdrop) return;\n              const pointed = getPointedElement(textarea, backdrop, e);\n              if (pointed) {\n                dispatchClonedMouseEvent(pointed, e.nativeEvent);\n              }\n            },\n            [onClick]\n          )}\n          onMouseDown={useCallback(\n            (e: React.MouseEvent<HTMLInputElement>) => {\n              onMouseDown?.(e);\n              selectionStore._update();\n              const MOUSE_UP = \"mouseup\";\n              const mouseup = () => {\n                selectionStore._update();\n                document.removeEventListener(MOUSE_UP, mouseup);\n              };\n              document.addEventListener(MOUSE_UP, mouseup);\n              const textarea = textAreaRef.current;\n              const backdrop = backdropRef.current;\n              if (!textarea || !backdrop) return;\n              const pointed = getPointedElement(textarea, backdrop, e);\n              if (pointed) {\n                dispatchClonedMouseEvent(pointed, e.nativeEvent);\n              }\n            },\n            [onMouseDown]\n          )}\n          onMouseUp={useCallback(\n            (e: React.MouseEvent<HTMLInputElement>) => {\n              onMouseUp?.(e);\n              const textarea = textAreaRef.current;\n              const backdrop = backdropRef.current;\n              if (!textarea || !backdrop) return;\n              const pointed = getPointedElement(textarea, backdrop, e);\n              if (pointed) {\n                dispatchClonedMouseEvent(pointed, e.nativeEvent);\n              }\n            },\n            [onMouseUp]\n          )}\n          onMouseMove={useCallback(\n            (e: React.MouseEvent<HTMLInputElement>) => {\n              onMouseMove?.(e);\n              const textarea = textAreaRef.current;\n              const backdrop = backdropRef.current;\n              if (!textarea || !backdrop) return;\n              const pointed = getPointedElement(textarea, backdrop, e);\n              dispatchMouseMoveEvent(pointed, pointedRef, e.nativeEvent);\n            },\n            [onMouseMove]\n          )}\n          onMouseLeave={useCallback(\n            (e: React.MouseEvent<HTMLInputElement>) => {\n              onMouseLeave?.(e);\n              dispatchMouseOutEvent(pointedRef, e.nativeEvent, null);\n            },\n            [onMouseLeave]\n          )}\n          onFocus={useCallback(\n            (e: React.FocusEvent<HTMLInputElement>) => {\n              onFocus?.(e);\n              setFocused(true);\n            },\n            [onFocus]\n          )}\n          onBlur={useCallback(\n            (e: React.FocusEvent<HTMLInputElement>) => {\n              onBlur?.(e);\n              setFocused(false);\n            },\n            [onBlur]\n          )}\n        />\n      </div>\n    );\n  }\n);\n","import { StoryObj } from \"@storybook/react\";\nimport { useState } from \"react\";\nimport { RichInput } from \"../../src\";\n\nexport default {\n  component: RichInput,\n};\n\nconst style = { paddingLeft: 10, paddingRight: 10 };\n\nexport const Basic: StoryObj = {\n  render: () => {\n    const [text, setText] = useState(\"Lorem ipsum\");\n    return (\n      <RichInput\n        style={style}\n        onChange={(e) => setText(e.target.value)}\n        value={text}\n      >\n        {(v) => {\n          return v.split(\"\").map((t, i) => (\n            <span key={i} style={{ color: i % 2 === 0 ? \"red\" : undefined }}>\n              {t}\n            </span>\n          ));\n        }}\n      </RichInput>\n    );\n  },\n};\n"],"names":["CARET_DETECTOR","_jsx","RichInput","forwardRef","render","value","autoHeight","style","onScroll","onInput","onCompositionStart","onCompositionUpdate","onCompositionEnd","onKeyDown","onClick","onMouseDown","onMouseUp","onMouseMove","onMouseLeave","onFocus","onBlur","onSelectionChange","propRef","textAreaRef","useRef","backdropRef","left","top","setPos","useState","width","height","hPadding","vPadding","setRect","focused","setFocused","caretColorRef","pointedRef","selectionStore","initSelectionStore","selectionStart","selectionEnd","useSyncExternalStore","totalWidth","totalHeight","useImperativeHandle","el","overrides","sel","args","text","start","end","preserve","document","target","prop","value2","useLayoutEffect","textarea","observer","entry","contentRect","borderBoxSize","style2","getStyle","backdrop","syncBackdropStyle","useEffect","rect","rangeAtIndex","isSafari","scrollHeight","_jsxs","useMemo","s","k","stopPropagation","props","useCallback","pointed","getPointedElement","dispatchClonedMouseEvent","MOUSE_UP","mouseup","dispatchMouseMoveEvent","dispatchMouseOutEvent","_2Input_stories","component","paddingLeft","paddingRight","Basic","setText","e","v","split","map","t","i","color","undefined"],"mappings":"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"}