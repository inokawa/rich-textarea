import{j as V}from"./observer-B5GHaPvN.js";import{r as E}from"./index-RYns6xqu.js";import{R as J}from"./textarea-DZOz3AQ5.js";class Q{constructor(a,i){this.listeners=new Set,this._batching=!1,this._flushing=0,this.subscribe=t=>{var e,s;this.listeners.add(t);const n=(s=(e=this.options)==null?void 0:e.onSubscribe)==null?void 0:s.call(e,t,this);return()=>{this.listeners.delete(t),n==null||n()}},this.setState=t=>{var e,s,n;const o=this.state;this.state=(e=this.options)!=null&&e.updateFn?this.options.updateFn(o)(t):t(o),(n=(s=this.options)==null?void 0:s.onUpdate)==null||n.call(s),this._flush()},this._flush=()=>{if(this._batching)return;const t=++this._flushing;this.listeners.forEach(e=>{this._flushing===t&&e()})},this.batch=t=>{if(this._batching)return t();this._batching=!0,t(),this._batching=!1,this._flush()},this.state=a,this.options=i}}function O(r,a){return typeof r=="function"?r(a):r}function X(r,a){return K(a).reduce((t,e)=>{if(t===null)return null;if(typeof t<"u")return t[e]},r)}function C(r,a,i){const t=K(a);function e(s){if(!t.length)return O(i,s);const n=t.shift();if(typeof n=="string"||typeof n=="number"&&!Array.isArray(s))return typeof s=="object"?(s===null&&(s={}),{...s,[n]:e(s[n])}):{[n]:e()};if(Array.isArray(s)&&typeof n=="number"){const o=s.slice(0,n);return[...o.length?o:new Array(n),e(s[n]),...s.slice(n+1)]}return[...new Array(n),e()]}return e(r)}function at(r,a){const i=K(a);function t(e){if(!e)return;if(i.length===1){const n=i[0];if(Array.isArray(e)&&typeof n=="number")return e.filter((d,c)=>c!==n);const{[n]:o,...l}=e;return l}const s=i.shift();if(typeof s=="string"&&typeof e=="object")return{...e,[s]:t(e[s])};if(typeof s=="number"&&Array.isArray(e)){if(s>=e.length)return e;const n=e.slice(0,s);return[...n.length?n:new Array(s),t(e[s]),...e.slice(s+1)]}throw new Error("It seems we have created an infinite loop in deleteBy. ")}return t(r)}const rt=/^(\d*)$/gm,nt=/\.(\d*)\./gm,ot=/^(\d*)\./gm,lt=/\.(\d*$)/gm,ut=/\.{2,}/gm,B="__int__",k=`${B}$1`;function K(r){if(Array.isArray(r))return[...r];if(typeof r!="string")throw new Error("Path must be a string.");return r.replaceAll("[",".").replaceAll("]","").replace(rt,k).replace(nt,`.${k}.`).replace(ot,`${k}.`).replace(lt,`.${k}`).replace(ut,".").split(".").map(a=>a.indexOf(B)===0?parseInt(a.substring(B.length),10):a)}function dt(r){return!(Array.isArray(r)&&r.length===0)}function L(r,a){const{asyncDebounceMs:i}=a,{onChangeAsync:t,onBlurAsync:e,onSubmitAsync:s,onBlurAsyncDebounceMs:n,onChangeAsyncDebounceMs:o}=a.validators||{},l=i??0,d={cause:"change",validate:t,debounceMs:o??l},c={cause:"blur",validate:e,debounceMs:n??l},f={cause:"submit",validate:s,debounceMs:0},u=h=>({...h,debounceMs:0});switch(r){case"submit":return[u(d),u(c),f];case"blur":return[c];case"change":return[d];case"server":default:return[]}}function R(r,a){const{onChange:i,onBlur:t,onSubmit:e}=a.validators||{},s={cause:"change",validate:i},n={cause:"blur",validate:t},o={cause:"submit",validate:e},l={cause:"server",validate:()=>{}};switch(r){case"submit":return[s,n,o,l];case"server":return[l];case"blur":return[n,l];case"change":default:return[s,l]}}function D(r){return{values:r.values??{},errors:r.errors??[],errorMap:r.errorMap??{},fieldMeta:r.fieldMeta??{},canSubmit:r.canSubmit??!0,isFieldsValid:r.isFieldsValid??!1,isFieldsValidating:r.isFieldsValidating??!1,isFormValid:r.isFormValid??!1,isFormValidating:r.isFormValidating??!1,isSubmitted:r.isSubmitted??!1,isSubmitting:r.isSubmitting??!1,isTouched:r.isTouched??!1,isBlurred:r.isBlurred??!1,isPristine:r.isPristine??!0,isDirty:r.isDirty??!1,isValid:r.isValid??!1,isValidating:r.isValidating??!1,submissionAttempts:r.submissionAttempts??0,validationMetaMap:r.validationMetaMap??{onChange:void 0,onBlur:void 0,onSubmit:void 0,onMount:void 0,onServer:void 0}}}const ct=r=>typeof r=="object";class ht{constructor(a){var i;this.options={},this.fieldInfo={},this.prevTransformArray=[],this.mount=()=>{const{onMount:t}=this.options.validators||{};if(!t)return;const e=this.runValidator({validate:t,value:{value:this.state.values,formApi:this,validationSource:"form"},type:"validate"});e&&this.store.setState(s=>({...s,errorMap:{...s.errorMap,onMount:e}}))},this.update=t=>{if(!t)return;const e=this.options;this.options=t,this.store.batch(()=>{const s=t.defaultValues&&t.defaultValues!==e.defaultValues&&!this.state.isTouched,n=t.defaultState!==e.defaultState&&!this.state.isTouched;this.store.setState(()=>D(Object.assign({},this.state,n?t.defaultState:{},s?{values:t.defaultValues}:{})))})},this.reset=(t,e)=>{const{fieldMeta:s}=this.state,n=this.resetFieldMeta(s);t&&!(e!=null&&e.keepDefaultValues)&&(this.options={...this.options,defaultValues:t}),this.store.setState(()=>{var o;return D({...this.options.defaultState,values:t??this.options.defaultValues??((o=this.options.defaultState)==null?void 0:o.values),fieldMeta:n})})},this.validateAllFields=async t=>{const e=[];return this.store.batch(()=>{Object.values(this.fieldInfo).forEach(n=>{if(!n.instance)return;const o=n.instance;e.push(Promise.resolve().then(()=>o.validate(t))),n.instance.state.meta.isTouched||n.instance.setMeta(l=>({...l,isTouched:!0})),n.instance.state.meta.isBlurred||n.instance.setMeta(l=>({...l,isBlurred:!0}))})}),(await Promise.all(e)).flat()},this.validateArrayFieldsStartingFrom=async(t,e,s)=>{const n=this.getFieldValue(t),o=Array.isArray(n)?Math.max(n.length-1,0):null,l=[`${t}[${e}]`];for(let u=e+1;u<=(o??0);u++)l.push(`${t}[${u}]`);const d=Object.keys(this.fieldInfo).filter(u=>l.some(h=>u.startsWith(h))),c=[];return this.store.batch(()=>{d.forEach(u=>{c.push(Promise.resolve().then(()=>this.validateField(u,s)))})}),(await Promise.all(c)).flat()},this.validateField=(t,e)=>{var s;const n=(s=this.fieldInfo[t])==null?void 0:s.instance;return n?(n.state.meta.isTouched||n.setMeta(o=>({...o,isTouched:!0})),n.state.meta.isBlurred||n.setMeta(o=>({...o,isBlurred:!0})),n.validate(e)):[]},this.validateSync=t=>{const e=R(t,this.options);let s=!1;const n={};this.store.batch(()=>{for(const l of e){if(!l.validate)continue;const d=this.runValidator({validate:l.validate,value:{value:this.state.values,formApi:this,validationSource:"form"},type:"validate"}),{formError:c,fieldErrors:f}=U(d),u=I(l.cause);if(f)for(const[h,v]of Object.entries(f)){const F={...n[h]||{},[u]:v};n[h]=F;const M=this.getFieldMeta(h);M&&M.errorMap[u]!==v&&this.setFieldMeta(h,p=>({...p,errorMap:{...p.errorMap,[u]:v}}))}this.state.errorMap[u]!==c&&this.store.setState(h=>({...h,errorMap:{...h.errorMap,[u]:c}})),(c||f)&&(s=!0)}});const o=I("submit");return this.state.errorMap[o]&&t!=="submit"&&!s&&this.store.setState(l=>({...l,errorMap:{...l.errorMap,[o]:void 0}})),{hasErrored:s,fieldsErrorMap:n}},this.validateAsync=async t=>{const e=L(t,this.options);this.state.isFormValidating||this.store.setState(d=>({...d,isFormValidating:!0}));const s=[];let n;for(const d of e){if(!d.validate)continue;const c=I(d.cause),f=this.state.validationMetaMap[c];f==null||f.lastAbortController.abort();const u=new AbortController;this.state.validationMetaMap[c]={lastAbortController:u},s.push(new Promise(async h=>{let v;try{v=await new Promise((p,S)=>{setTimeout(async()=>{if(u.signal.aborted)return p(void 0);try{p(await this.runValidator({validate:d.validate,value:{value:this.state.values,formApi:this,validationSource:"form",signal:u.signal},type:"validateAsync"}))}catch(b){S(b)}},d.debounceMs)})}catch(p){v=p}const{formError:y,fieldErrors:F}=U(v);F&&(n=n?{...n,...F}:F);const M=I(d.cause);if(n)for(const[p,S]of Object.entries(n)){const b=this.getFieldMeta(p);b&&b.errorMap[M]!==S&&this.setFieldMeta(p,_=>({..._,errorMap:{..._.errorMap,[M]:S}}))}this.store.setState(p=>({...p,errorMap:{...p.errorMap,[M]:y}})),h(n?{fieldErrors:n,errorMapKey:M}:void 0)}))}let o=[];const l={};if(s.length){o=await Promise.all(s);for(const d of o)if(d!=null&&d.fieldErrors){const{errorMapKey:c}=d;for(const[f,u]of Object.entries(d.fieldErrors)){const v={...l[f]||{},[c]:u};l[f]=v}}}return this.store.setState(d=>({...d,isFormValidating:!1})),l},this.validate=t=>{const{hasErrored:e,fieldsErrorMap:s}=this.validateSync(t);return e&&!this.options.asyncAlways?s:this.validateAsync(t)},this.handleSubmit=async()=>{var t,e,s,n;if(this.store.setState(l=>({...l,isSubmitted:!1,submissionAttempts:l.submissionAttempts+1})),!this.state.canSubmit)return;this.store.setState(l=>({...l,isSubmitting:!0}));const o=()=>{this.store.setState(l=>({...l,isSubmitting:!1}))};if(await this.validateAllFields("submit"),!this.state.isValid){o(),(e=(t=this.options).onSubmitInvalid)==null||e.call(t,{value:this.state.values,formApi:this});return}this.store.batch(()=>{Object.values(this.fieldInfo).forEach(l=>{var d,c,f;(f=(c=(d=l.instance)==null?void 0:d.options.listeners)==null?void 0:c.onSubmit)==null||f.call(c,{value:l.instance.state.value,fieldApi:l.instance})})});try{await((n=(s=this.options).onSubmit)==null?void 0:n.call(s,{value:this.state.values,formApi:this})),this.store.batch(()=>{this.store.setState(l=>({...l,isSubmitted:!0})),o()})}catch(l){throw o(),l}},this.getFieldValue=t=>X(this.state.values,t),this.getFieldMeta=t=>this.state.fieldMeta[t],this.getFieldInfo=t=>{var e;return(e=this.fieldInfo)[t]||(e[t]={instance:null,validationMetaMap:{onChange:void 0,onBlur:void 0,onSubmit:void 0,onMount:void 0,onServer:void 0}})},this.setFieldMeta=(t,e)=>{this.store.setState(s=>({...s,fieldMeta:{...s.fieldMeta,[t]:O(e,s.fieldMeta[t])}}))},this.resetFieldMeta=t=>Object.keys(t).reduce((e,s)=>{const n=s;return e[n]={isValidating:!1,isTouched:!1,isBlurred:!1,isDirty:!1,isPristine:!0,errors:[],errorMap:{}},e},{}),this.setFieldValue=(t,e,s)=>{const n=(s==null?void 0:s.dontUpdateMeta)??!1;this.store.batch(()=>{n||this.setFieldMeta(t,o=>({...o,isTouched:!0,isBlurred:!0,isDirty:!0,errorMap:{...o==null?void 0:o.errorMap,onMount:void 0}})),this.store.setState(o=>({...o,values:C(o.values,t,e)}))})},this.deleteField=t=>{this.store.setState(e=>{const s={...e};return s.values=at(s.values,t),delete s.fieldMeta[t],s}),delete this.fieldInfo[t]},this.pushFieldValue=(t,e,s)=>{this.setFieldValue(t,n=>[...Array.isArray(n)?n:[],e],s),this.validateField(t,"change")},this.insertFieldValue=async(t,e,s,n)=>{this.setFieldValue(t,o=>[...o.slice(0,e),s,...o.slice(e)],n),await this.validateField(t,"change")},this.replaceFieldValue=async(t,e,s,n)=>{this.setFieldValue(t,o=>o.map((l,d)=>d===e?s:l),n),await this.validateField(t,"change"),await this.validateArrayFieldsStartingFrom(t,e,"change")},this.removeFieldValue=async(t,e,s)=>{const n=this.getFieldValue(t),o=Array.isArray(n)?Math.max(n.length-1,0):null;if(this.setFieldValue(t,l=>l.filter((d,c)=>c!==e),s),o!==null){const l=`${t}[${o}]`;Object.keys(this.fieldInfo).filter(c=>c.startsWith(l)).forEach(c=>this.deleteField(c))}await this.validateField(t,"change"),await this.validateArrayFieldsStartingFrom(t,e,"change")},this.swapFieldValues=(t,e,s,n)=>{this.setFieldValue(t,o=>{const l=o[e],d=o[s];return C(C(o,`${e}`,d),`${s}`,l)},n),this.validateField(t,"change"),this.validateField(`${t}[${e}]`,"change"),this.validateField(`${t}[${s}]`,"change")},this.moveFieldValues=(t,e,s,n)=>{this.setFieldValue(t,o=>(o.splice(s,0,o.splice(e,1)[0]),o),n),this.validateField(t,"change"),this.validateField(`${t}[${e}]`,"change"),this.validateField(`${t}[${s}]`,"change")},this.store=new Q(D({...a==null?void 0:a.defaultState,values:(a==null?void 0:a.defaultValues)??((i=a==null?void 0:a.defaultState)==null?void 0:i.values),isFormValid:!0}),{onUpdate:()=>{var t,e,s,n;let{state:o}=this.store;const l=Object.values(o.fieldMeta),d=l.some(m=>m==null?void 0:m.isValidating),c=!l.some(m=>(m==null?void 0:m.errorMap)&&dt(Object.values(m.errorMap).filter(Boolean))),f=l.some(m=>m==null?void 0:m.isTouched),u=l.some(m=>m==null?void 0:m.isBlurred);f&&((t=o==null?void 0:o.errorMap)!=null&&t.onMount)&&(o.errorMap.onMount=void 0);const h=l.some(m=>m==null?void 0:m.isDirty),v=!h,y=!!((e=o.errorMap)!=null&&e.onMount||l.some(m=>{var g;return(g=m==null?void 0:m.errorMap)==null?void 0:g.onMount})),F=d||o.isFormValidating;o.errors=Object.values(o.errorMap).reduce((m,g)=>g===void 0?m:typeof g=="string"?(m.push(g),m):(g&&ct(g)&&m.push(g.form),m),[]);const M=o.errors.length===0,p=c&&M,S=o.submissionAttempts===0&&!f&&!y||!F&&!o.isSubmitting&&p;o={...o,isFieldsValidating:d,isFieldsValid:c,isFormValid:M,isValid:p,canSubmit:S,isTouched:f,isBlurred:u,isPristine:v,isDirty:h},this.state=o,this.store.state=this.state;const b=((s=this.options.transform)==null?void 0:s.deps)??[];(b.length!==this.prevTransformArray.length||b.some((m,g)=>m!==this.prevTransformArray[g]))&&((n=this.options.transform)==null||n.fn(this),this.store.state=this.state,this.prevTransformArray=b)}}),this.state=this.store.state,this.update(a||{})}runValidator(a){const i=this.options.validatorAdapter;return i&&typeof a.validate!="function"?i()[a.type](a.value,a.validate):a.validate(a.value)}setErrorMap(a){this.store.setState(i=>({...i,errorMap:{...i.errorMap,...a}}))}}function U(r){if(r){if(typeof r=="object"){const a=U(r.form).formError,i=r.fields;return{formError:a,fieldErrors:i}}return typeof r!="string"?{formError:"Invalid Form Values"}:{formError:r}}return{formError:void 0}}function I(r){switch(r){case"submit":return"onSubmit";case"blur":return"onBlur";case"mount":return"onMount";case"server":return"onServer";case"change":default:return"onChange"}}class ft{constructor(a){this.options={},this.mount=()=>{var i,t;const e=this.getInfo();e.instance=this;const s=this.form.store.subscribe(()=>{this.store.batch(()=>{const o=this.getValue(),l=this.getMeta();o!==this.state.value&&this.store.setState(d=>({...d,value:o})),l!==this.state.meta&&this.store.setState(d=>({...d,meta:l}))})});this.update(this.options);const{onMount:n}=this.options.validators||{};if(n){const o=this.runValidator({validate:n,value:{value:this.state.value,fieldApi:this,validationSource:"field"},type:"validate"});o&&this.setMeta(l=>({...l,errorMap:{...l==null?void 0:l.errorMap,onMount:o}}))}return(t=(i=this.options.listeners)==null?void 0:i.onMount)==null||t.call(i,{value:this.state.value,fieldApi:this}),()=>{s()}},this.update=i=>{if(this.state.value===void 0){const t=X(i.form.options.defaultValues,i.name);i.defaultValue!==void 0?this.setValue(i.defaultValue,{dontUpdateMeta:!0}):t!==void 0&&this.setValue(t,{dontUpdateMeta:!0})}this._getMeta()===void 0&&this.setMeta(this.state.meta),this.options=i},this.getValue=()=>this.form.getFieldValue(this.name),this.setValue=(i,t)=>{var e,s;this.form.setFieldValue(this.name,i,t),(s=(e=this.options.listeners)==null?void 0:e.onChange)==null||s.call(e,{value:this.state.value,fieldApi:this}),this.validate("change")},this._getMeta=()=>this.form.getFieldMeta(this.name),this.getMeta=()=>this._getMeta()??{isValidating:!1,isTouched:!1,isBlurred:!1,isDirty:!1,isPristine:!0,errors:[],errorMap:{},...this.options.defaultMeta},this.setMeta=i=>this.form.setFieldMeta(this.name,i),this.getInfo=()=>this.form.getFieldInfo(this.name),this.pushValue=(i,t)=>this.form.pushFieldValue(this.name,i,t),this.insertValue=(i,t,e)=>this.form.insertFieldValue(this.name,i,t,e),this.replaceValue=(i,t,e)=>this.form.replaceFieldValue(this.name,i,t,e),this.removeValue=(i,t)=>this.form.removeFieldValue(this.name,i,t),this.swapValues=(i,t,e)=>this.form.swapFieldValues(this.name,i,t,e),this.moveValue=(i,t,e)=>this.form.moveFieldValues(this.name,i,t,e),this.getLinkedFields=i=>{const t=Object.values(this.form.fieldInfo),e=[];for(const s of t){if(!s.instance)continue;const{onChangeListenTo:n,onBlurListenTo:o}=s.instance.options.validators||{};i==="change"&&(n!=null&&n.includes(this.name))&&e.push(s.instance),i==="blur"&&(o!=null&&o.includes(this.name))&&e.push(s.instance)}return e},this.validateSync=(i,t)=>{const e=R(i,this.options),n=this.getLinkedFields(i).reduce((d,c)=>{const f=R(i,c.options);return f.forEach(u=>{u.field=c}),d.concat(f)},[]);let o=!1;this.form.store.batch(()=>{const d=(c,f)=>{const u=T(f.cause),h=f.validate?N(c.runValidator({validate:f.validate,value:{value:c.getValue(),validationSource:"field",fieldApi:c},type:"validate"})):t[u];c.state.meta.errorMap[u]!==h&&c.setMeta(v=>({...v,errorMap:{...v.errorMap,[T(f.cause)]:h||t[u]}})),(h||t[u])&&(o=!0)};for(const c of e)d(this,c);for(const c of n)c.validate&&d(c.field,c)});const l=T("submit");return this.state.meta.errorMap[l]&&i!=="submit"&&!o&&this.setMeta(d=>({...d,errorMap:{...d.errorMap,[l]:void 0}})),{hasErrored:o}},this.validateAsync=async(i,t)=>{const e=L(i,this.options),s=await t,n=this.getLinkedFields(i),o=n.reduce((u,h)=>{const v=L(i,h.options);return v.forEach(y=>{y.field=h}),u.concat(v)},[]);this.state.meta.isValidating||this.setMeta(u=>({...u,isValidating:!0}));for(const u of n)u.setMeta(h=>({...h,isValidating:!0}));const l=[],d=[],c=(u,h,v)=>{const y=T(h.cause),F=u.getInfo().validationMetaMap[y];F==null||F.lastAbortController.abort();const M=new AbortController;this.getInfo().validationMetaMap[y]={lastAbortController:M},v.push(new Promise(async p=>{var S;let b;try{b=await new Promise((A,it)=>{this.timeoutIds[h.cause]&&clearTimeout(this.timeoutIds[h.cause]),this.timeoutIds[h.cause]=setTimeout(async()=>{if(M.signal.aborted)return A(void 0);try{A(await this.runValidator({validate:h.validate,value:{value:u.getValue(),fieldApi:u,signal:M.signal,validationSource:"field"},type:"validateAsync"}))}catch(st){it(st)}},h.debounceMs)})}catch(A){b=A}if(M.signal.aborted)return p(void 0);const _=N(b),m=(S=s[this.name])==null?void 0:S[y],g=_||m;u.setMeta(A=>({...A,errorMap:{...A==null?void 0:A.errorMap,[y]:g}})),p(g)}))};for(const u of e)u.validate&&c(this,u,l);for(const u of o)u.validate&&c(u.field,u,d);let f=[];(l.length||d.length)&&(f=await Promise.all(l),await Promise.all(d)),this.setMeta(u=>({...u,isValidating:!1}));for(const u of n)u.setMeta(h=>({...h,isValidating:!1}));return f.filter(Boolean)},this.validate=i=>{var t;if(!this.state.meta.isTouched)return[];const{fieldsErrorMap:e}=this.form.validateSync(i),{hasErrored:s}=this.validateSync(i,e[this.name]??{});if(s&&!this.options.asyncAlways)return(t=this.getInfo().validationMetaMap[T(i)])==null||t.lastAbortController.abort(),this.state.meta.errors;const n=this.form.validateAsync(i);return this.validateAsync(i,n)},this.handleChange=i=>{this.setValue(i)},this.handleBlur=()=>{var i,t;this.state.meta.isTouched||(this.setMeta(s=>({...s,isTouched:!0})),this.validate("change")),this.state.meta.isBlurred||this.setMeta(s=>({...s,isBlurred:!0})),this.validate("blur"),(t=(i=this.options.listeners)==null?void 0:i.onBlur)==null||t.call(i,{value:this.state.value,fieldApi:this})},this.form=a.form,this.name=a.name,this.timeoutIds={},a.defaultValue!==void 0&&this.form.setFieldValue(this.name,a.defaultValue,{dontUpdateMeta:!0}),this.store=new Q({value:this.getValue(),meta:this._getMeta()??{isValidating:!1,isTouched:!1,isBlurred:!1,isDirty:!1,isPristine:!0,errors:[],errorMap:{},...a.defaultMeta}},{onUpdate:()=>{const i=this.store.state;i.meta.errors=Object.values(i.meta.errorMap).filter(t=>t!==void 0),i.meta.isPristine=!i.meta.isDirty,this.prevState=i,this.state=i}}),this.state=this.store.state,this.prevState=this.state,this.options=a}runValidator(a){const i=[this.form.options.validatorAdapter,this.options.validatorAdapter];for(const t of i)if(t&&typeof a.validate!="function")return t()[a.type](a.value,a.validate);return a.validate(a.value)}setErrorMap(a){this.setMeta(i=>({...i,errorMap:{...i.errorMap,...a}}))}}function N(r){if(r)return typeof r!="string"?"Invalid Form Values":r}function T(r){switch(r){case"submit":return"onSubmit";case"blur":return"onBlur";case"mount":return"onMount";case"server":return"onServer";case"change":default:return"onChange"}}var Y={exports:{}},Z={},q={exports:{}},tt={};/**
 * @license React
 * use-sync-external-store-shim.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var w=E;function mt(r,a){return r===a&&(r!==0||1/r===1/a)||r!==r&&a!==a}var vt=typeof Object.is=="function"?Object.is:mt,pt=w.useState,Mt=w.useEffect,yt=w.useLayoutEffect,gt=w.useDebugValue;function bt(r,a){var i=a(),t=pt({inst:{value:i,getSnapshot:a}}),e=t[0].inst,s=t[1];return yt(function(){e.value=i,e.getSnapshot=a,j(e)&&s({inst:e})},[r,i,a]),Mt(function(){return j(e)&&s({inst:e}),r(function(){j(e)&&s({inst:e})})},[r]),gt(i),i}function j(r){var a=r.getSnapshot;r=r.value;try{var i=a();return!vt(r,i)}catch{return!0}}function Vt(r,a){return a()}var Ft=typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"?Vt:bt;tt.useSyncExternalStore=w.useSyncExternalStore!==void 0?w.useSyncExternalStore:Ft;q.exports=tt;var St=q.exports;/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.js
 *
 * Copyright (c) Meta Platforms, Inc. and affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var P=E,At=St;function Et(r,a){return r===a&&(r!==0||1/r===1/a)||r!==r&&a!==a}var wt=typeof Object.is=="function"?Object.is:Et,_t=At.useSyncExternalStore,Tt=P.useRef,kt=P.useEffect,It=P.useMemo,$t=P.useDebugValue;Z.useSyncExternalStoreWithSelector=function(r,a,i,t,e){var s=Tt(null);if(s.current===null){var n={hasValue:!1,value:null};s.current=n}else n=s.current;s=It(function(){function l(h){if(!d){if(d=!0,c=h,h=t(h),e!==void 0&&n.hasValue){var v=n.value;if(e(v,h))return f=v}return f=h}if(v=f,wt(c,h))return v;var y=t(h);return e!==void 0&&e(v,y)?(c=h,v):(c=h,f=y)}var d=!1,c,f,u=i===void 0?null:i;return[function(){return l(a())},u===null?void 0:function(){return l(u())}]},[a,i,t,e]);var o=_t(r,s[0],s[1]);return kt(function(){n.hasValue=!0,n.value=o},[o]),$t(o),o};Y.exports=Z;var xt=Y.exports;function z(r,a=i=>i){return xt.useSyncExternalStoreWithSelector(r.subscribe,()=>r.state,()=>r.state,a,Ot)}function Ot(r,a){if(Object.is(r,a))return!0;if(typeof r!="object"||r===null||typeof a!="object"||a===null)return!1;if(r instanceof Map&&a instanceof Map){if(r.size!==a.size)return!1;for(const[t,e]of r)if(!a.has(t)||!Object.is(e,a.get(t)))return!1;return!0}if(r instanceof Set&&a instanceof Set){if(r.size!==a.size)return!1;for(const t of r)if(!a.has(t))return!1;return!0}const i=Object.keys(r);if(i.length!==Object.keys(a).length)return!1;for(let t=0;t<i.length;t++)if(!Object.prototype.hasOwnProperty.call(a,i[t])||!Object.is(r[i[t]],a[i[t]]))return!1;return!0}const x=typeof window<"u"?E.useLayoutEffect:E.useEffect;function Pt(r){const[a]=E.useState(()=>{const t=new ft({...r,form:r.form,name:r.name});return t.Field=et,t});return x(a.mount,[a]),x(()=>{a.update(r)}),z(a.store,r.mode==="array"?i=>[i.meta,Object.keys(i.value??[]).length]:void 0),a}const et=({children:r,...a})=>{const i=Pt(a),t=E.useMemo(()=>O(r,i),[r,i,i.state.value,i.state.meta]);return V.jsx(V.Fragment,{children:t})};function Ct({form:r,selector:a,children:i}){const t=z(r.store,a);return O(i,t)}function Dt(r){const[a]=E.useState(()=>{const i=new ht(r),t=i;return t.Field=function(s){return V.jsx(et,{...s,form:i})},t.Subscribe=e=>V.jsx(Ct,{form:i,selector:e.selector,children:e.children}),t});return x(a.mount,[]),z(a.store,i=>i.isSubmitting),x(()=>{a.update(r)}),a}const Ut={component:J},jt={width:"600px",height:"400px"},$={name:"With Tanstack Form",render:()=>{const r=Dt({defaultValues:{text:"Hello tanstack"},onSubmit:a=>alert(JSON.stringify(a.value))});return V.jsxs("form",{onSubmit:a=>{a.preventDefault(),a.stopPropagation(),r.handleSubmit()},children:[V.jsx(r.Field,{name:"text",validators:{onChange:({value:a})=>{if(!a)return"This field is required";if(!a.toLowerCase().includes("tanstack"))return"Text must include tanstack"}},children:a=>V.jsxs(V.Fragment,{children:[V.jsx(J,{style:jt,name:a.name,value:a.state.value,onChange:i=>a.handleChange(i.target.value),onBlur:a.handleBlur,children:i=>i.split("").map((t,e)=>V.jsx("span",{style:{color:"tanstack".includes(t.toLowerCase())?"tan":void 0},children:t},e))}),a.state.meta.errors&&V.jsx("span",{style:{color:"red"},children:a.state.meta.errors.join(", ")})]})}),V.jsx("button",{type:"submit",children:"submit"})]})}};var W,G,H;$.parameters={...$.parameters,docs:{...(W=$.parameters)==null?void 0:W.docs,source:{originalSource:`{
  name: "With Tanstack Form",
  render: () => {
    const form = useForm({
      defaultValues: {
        text: "Hello tanstack"
      },
      onSubmit: data => alert(JSON.stringify(data.value))
    });
    return <form onSubmit={e => {
      e.preventDefault();
      e.stopPropagation();
      form.handleSubmit();
    }}>
        <form.Field name="text" validators={{
        onChange: ({
          value
        }) => {
          if (!value) {
            return "This field is required";
          }
          if (!value.toLowerCase().includes("tanstack")) {
            return "Text must include tanstack";
          }
        }
      }}>
          {field => <>
              <RichTextarea style={style} name={field.name} value={field.state.value} onChange={e => field.handleChange(e.target.value)} onBlur={field.handleBlur}>
                {v => {
              return v.split("").map((t, i) => <span key={i} style={{
                color: "tanstack".includes(t.toLowerCase()) ? "tan" : undefined
              }}>
                      {t}
                    </span>);
            }}
              </RichTextarea>
              {field.state.meta.errors && <span style={{
            color: "red"
          }}>
                  {field.state.meta.errors.join(", ")}
                </span>}
            </>}
        </form.Field>
        <button type="submit">submit</button>
      </form>;
  }
}`,...(H=(G=$.parameters)==null?void 0:G.docs)==null?void 0:H.source}}};const Kt=["Default"];export{$ as Default,Kt as __namedExportsOrder,Ut as default};
